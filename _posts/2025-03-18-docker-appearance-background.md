---
title: 도커 등장 배경
description: VM vs Container
# author: d_o0o_b
categories: [Dev-Notes, Theory]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 개요

도커가 등장하게 된 배경은 소프트웨어 개발 및 배포 과정에서 발생하는 여러 가지 문제를 해결하기 위해서입니다. 이를 이해하기 위해선 당시 **개발 환경에서 겪던 주요 문제들**에 대해 먼저 살펴봐야 합니다.

#### 개발 환경에서 겪던 주요 문제들
개발 환경과 운영 환경의 불일치, 배포의 복잡성, 그리고 VM의 비효율성이 대표적인 문제였습니다.
> VM 환경에서 개발자가 Ubuntu 18.04에서 애플리케이션을 테스트했지만, 운영 서버는 Ubuntu 20.04라서 실행 중 라이브러리 버전 차이로 에러가 발생할 수 있음. Docker는 이런 문제를 해결한다.

<!-- ![Image](https://github.com/user-attachments/assets/15734cbc-1673-473e-a1f0-8e8351242a30?raw=true) -->


## 전통적인 구조

초기에는 애플리케이션을 물리 서버에서 직접 실행하는 방식이 일반적이었습니다. 하지만 다음과 같은 문제가 있었습니다.

- 하나의 애플리케이션이 과도한 리소스를 차지하면 다른 애플리케이션의 성능이 저하됨
- 서로 다른 애플리케이션 간의 라이브러리 충돌 문제 발생 (예: A 애플리케이션은 Python 2, B 애플리케이션은 Python 3을 요구)
- 애플리케이션마다 별도의 서버를 사용하면 리소스 낭비와 높은 유지보수 비용 발생

이러한 문제를 해결하기 위해 가상화 기술이 도입되었습니다.

### 구조

![Image](https://github.com/user-attachments/assets/fb02d3ef-98fc-4200-a81e-101bb4942e1f?raw=true)


## 가상 머신 (VM) 구조

가상화 기술은 하나의 물리 서버에서 여러 개의 가상 머신을 실행할 수 있도록 했습니다.

### 가상 머신 특징

- 애플리케이션 간 격리 보장 <br/>
    각 애플리케이션은 독립적인 VM에서 실행됨
- 리소스 활용 최적화 <br/>
    하나의 물리 서버에서 여러 VM을 실행하여 효율성 증가
- 보안성 향상 <br/>
    VM 간의 데이터 접근이 차단되어 일덩 수준의 보안 보장

### 단점

- 운영체제 오버헤드 <br/>
    각 VM은 자체 운영체제를 포함해야 하므로 리소스 소비 증가
- 부팅 속도 문제 <br/>
    VM을 실행하려면 OS 부팅이 필요하므로 시간이 오래 걸림
- 운영체제 관리 필요 <br/>
    각 VM마다 OS 패치 및 업데이트 필요

이러한 단점을 해결하기 위해 컨테이너(Container) 기술이 등장했습니다.

### 구조

![Image](https://github.com/user-attachments/assets/c24c4b08-92e4-4227-bd5c-a85bf2f9ebc6?raw=true)

- Physical Server(물리 서버) <br/>
    실제 하드웨어 장비
- Hypervisor <br/>
    여러 개의 가상 머신을 실행하고 관리하는 소프트웨어 (예: VMware, Hyper-V, VirtualBox 등)
- VM (Virtual Machine) <br/>
    하이퍼바이저 위에서 실행되는 가상 환경
    - 각 VM은 독립적인 Guest OS를 포함하며, 그 위에 필요한 라이브러리(Bins/Libs)와 애플리케이션을 설치하여 실행
    - VM 간 완벽한 격리가 가능하지만, Guest OS가 각각 존재하므로 무겁고 리소스 사용량이 큼
    - 부팅 시간이 길고, 운영체제별 패치 및 업데이트 관리가 필요함

## 컨테이너 구조

컨테이너 기술은 가상화 기술의 단점을 보완하면서도 애플리케이션 간의 격리를 유지할 수 있도록 발전했습니다. 컨테이너는 VM과 유사하지만 운영체제를 공유하는 특징을 가집니다.

### 특징

- 경량성 <br/>
    Guest OS가 필요 없으며, Host OS의 커널을 공유하여 실행됨
- 빠른 실행 속도 <br/>
    OS 부팅 없이 컨테이너를 즉시 실행 가능
- 일관된 환경 제공 <br/>
    개발, 테스트, 운영 환경 간 차이를 최소화
- 확장성 증가 <br/>
    컨테이너 이미지를 기반으로 손쉽게 배포 가능

### 구조

![Image](https://github.com/user-attachments/assets/40b943bb-b066-4f9d-b882-dad3b4680150?raw=true)

- Physical Server(물리 서버) <br/>
    실제 하드웨어 장비
- Host OS <br/>
    물리 서버에서 실행되는 운영체제 (예: Linux, Windows 등)
- Docker Engine <br/>
    컨테이너를 실행하고 관리하는 도커 실행 환경
- Container <br/>
    가상 머신과 달리 Guest OS를 포함하지 않고 Host OS의 커널을 공유하면서 독립적인 환경을 제공
    - 각 컨테이너는 필요한 라이브러리(Bins/Libs)와 애플리케이션(App)만 포함하여 경량화
    - VM과 달리 OS 부팅이 필요 없고, 실행 속도가 빠름
    - 프로세스 단위로 격리되며, 가상 머신보다 리소스를 훨씬 적게 사용
    - 컨테이너 이미지를 통해 손쉽게 배포 및 확장이 가능함

## 가상 머신 vs 도커 컨테이너

| 특징 | 가상 머신(VM)  | 도커(Container)  |
| :--------------------------- |:---------------------------|:---------------------------|
| 환경 설정  | OS, 네트워크, 패키지 등 개별 설정 필요 | Dockerfile로 환경 일관성 유지 | 
| 실행 방식  | OS 전체를 가상화| 애플리케이션 단위로 격리 | 
| 커널 공유 여부 | 각 VM마다 Guest OS 포함 | Host OS 커널 공유 | 
| 실행 속도  | 느림 (OS 부팅 필요) | 빠름 (즉시 실행 가능) |
| 자원 사용  | 무겁고 많은 리소스 필요 | 가볍고 효율적 |
| 확장성  | 새로운 서버 추가 시 설정 반복 | 컨테이너 개수만 늘리면 됨 |


## 기존 개발 및 배포 방식의 문제점

과거에는 소프트웨어를 개발한 후 운영 환경에 배포하는 과정에서 많은 어려움이 있었습니다.

1. 환경 차이에 따른 문제

    - 개발 환경(개발자 로컬 PC)과 운영 환경(서버) 간의 차이로 인해 "내 컴퓨터에서는 잘 됐는데?"라는 문제 종종 발생
    - 운영체제(OS), 라이브러리, 의존성 패키지 등이 서로 달라서 실행이 잘 안 되는 경우

2. 애플리케이션 배포의 복잡성

    - 애플리케이션을 배포하려면 수많은 설정을 직접 맞춰야 합니다.
    - 개발팀, 운영팀 간 협업이 어려워졌고, 배포 과정에서 문제가 발생할 가능성이 컸어.

3. 가상 머신(VM, Virtual Machine)의 비효율성

    - 기존에는 이러한 문제를 해결하기 위해 VM을 사용했어. 예를 들어, VMware, VirtualBox, AWS EC2 같은 기술
    - 하지만 VM은 운영체제(OS) 전체를 가상화해야 해서 무겁고 속도가 느리며, 많은 리소스를 차지하는 문제


## 도커의 등장

이러한 문제를 해결하기 위해 도커가 등장했습니다. 도커는 가상 머신 대신 컨테이너 라는 가벼운 가상화 기술을 제공합니다.

컨테이너 기반의 가상화 기술을 제공하는 대표적인 플랫폼입니다.

1. 컨테이너 기술 기반

    - 컨테이너는 OS 커널을 공유하면서도 독립된 실행 환경을 제공합니다.
    - 가상 머신보다 가볍고 빠르며 실행 속도가 훨씬 뛰어납니다.

2. 한 번 개발한 애플리케이션을 어디서나 동일하게 실행 가능

    - 도커를 사용하면 개발 환경과 운영 환경이 동일하게 유지되므로 "내 컴퓨터에서는 되는데?" 문제가 사라집니다.
    - 동일한 컨테이너 이미지를 어디서든 실행할 수 있어서 배포가 쉬워졌습니다.

3. 자동화 및 DevOps와의 연계

    - CI/CD(지속적 통합 및 배포) 환경에서 도커를 사용하면 소프트웨어 배포가 자동화되고 안정성이 높아집니다.
    - 마이크로서비스 아키텍처(MSA)와 결합되어 현대적인 클라우드 기반 애플리케이션 개발에 필수적인 기술이 되었습니다.


## 도커의 핵심 개념

- 이미지(Image) <br/>
    컨테이너 실행에 필요한 모든 요소(코드, 라이브러리, 설정 등)를 포함한 템플릿
- 컨테이너(Container) <br/> 
    이미지를 기반으로 실행되는 독립된 환경
- 도커허브(Docker Hub) <br/>
    이미지를 저장하고 공유하는 플랫폼
- 도커파일(Dockerfile) <br/>
    컨테이너 이미지를 자동으로 생성하는 스크립트


## 결론

도커는 기존의 환경 불일치 문제, 배포 복잡성, VM의 비효율성을 해결하기 위해 등장했어. 현재는 클라우드 환경과 DevOps 프로세스에서 필수적인 도구로 자리 잡았고, AWS, GCP, Azure 같은 클라우드 서비스와도 긴밀하게 연계되어 사용되고 있어.


## 궁금증들

### Hypervisor와 Docker Engine

❓ Hypervisor가 VM을 실행하고 관리하는 역할을 Docker에서 대신하는 게 Docker Engine인가?
<br/>
기능적으로는 비슷하지만, 동작 방식이 다르다.

- Hypervisor
    - 물리 서버에서 여러 개의 가상 운영체제(Guest OS)를 실행하고 관리하는 소프트웨어
    - VM을 구동하는 방식
- Docker Engine
    - Hypervisor처럼 개별 OS를 실행하는 게 아니라 컨테이너(애플리케이션)를 실행하고 관리하는 도구
    - 컨테이너를 관리하는 방식

| 특징 | Hypervisor (VM)  | Docker Engine (Container) |
| :--------------------------- |:---------------------------|:---------------------------|
| 실행 방식  | OS 전체를 가상화| 애플리케이션 단위로 격리 | 
| 운영 방식 | 	각 VM마다 OS 실행(무겁고 느림) | Host OS의 커널 공유(가볍고 빠름) | 
| 속도  | OS 부팅 필요 | 컨테이너 즉시 실행 |


### Guest OS와 Host OS, 커널 개념

#### Guest OS란?

- VM에서 실행되는 운영체제
- 가상 머신마다 독립적인 OS를 가짐 (ex: Windows, Linux 등)
- Hypervisor 위에서 실행되며 물리 서버의 Host OS와 별도로 존재

#### Host OS란?

- 물리 서버에서 직접 실행되는 운영체제
- if. MacBook에서 VirtualBox로 Ubuntu VM을 실행했다면
    - MacOS가 Host OS
    - VirtualBox 위에서 실행되는 Ubuntu가 Guest OS
<br/>
- Docker는 Guest OS가 없다 → Host OS 커널을 공유
    - Docker는 VM처럼 각 컨테이너마다 운영체제를 따로 가지지 않고 Host OS의 커널을 공유해서 사용
    - 그래서 VM보다 훨씬 가볍고 실행 속도가 빠르다

#### 커널이란?

- 운영체제(OS)에서 가장 핵심적인 부분
    - 하드웨어와 소프트웨어 사이에서 중개 역할
    - 파일 시스템, 프로세스 관리, 메모리 관리, 네트워크 관리 등을 담당
<br/>
- 커널 공유란?
    - VM: 각 Guest OS가 독립적인 커널을 가진다
    - Docker: Host OS의 커널을 공유하여 컨테이너를 실행

#### VM에서 운영체제별 패치/업데이트 관리를 해야 한다
각 Guest OS가 별도 운영체제이므로 개별적으로 업데이트해야 한다

- VM1(Ubuntu 18.04) → Ubuntu 20.04로 업그레이드 필요
- VM2(Windows 10) → Windows 11 업데이트 필요

#### Docker에서는 OS 업데이트 관리를 안 해도 되는건가?
Host OS만 업데이트하면 된다

- 컨테이너는 Host OS의 커널을 공유하기 때문에 개별 OS 업데이트가 필요 없다
- 하지만 컨테이너 내부 라이브러리는 업데이트해야 한다

### VM vs Docker 배포 방식 비교 (ex. AWS)

#### VM 기반 배포 
```
1. AWS EC2 생성 (Ubuntu VM)  
2. OS 환경 설정 (패키지 설치, 방화벽 설정 등)  
3. 애플리케이션 설치 (Node.js, Python, MySQL 등)  
4. 서비스 실행 (PM2, Systemd 등으로 관리)  
5. 배포 스크립트 작성 (CI/CD 자동화 어려움)  
```
- EC2안에 Node.js 부터 필요한 패키지 모두 설치 필요
- 개개별로 설치하기 때문에 버전 불일치 발생 가능성

❓VM은 자동화 배포가 어려운가?
<br/>
- 가능하지만 번거롭다
- 예를 들어 Ansible, Terraform 같은 인프라 자동화 도구를 사용해야 한다
- 반면, Docker는 기본적으로 CI/CD 자동화가 쉽다

#### Docker 기반 배포
```
1. Dockerfile 작성 → 컨테이너 이미지 생성  
2. Docker Hub에 이미지 업로드  
3. AWS EC2에서 컨테이너 실행  
4. CI/CD 파이프라인 구축 (GitHub Actions, AWS CodePipeline)  
```
- Docker 이미지를 어디서든 실행 가능 → 배포 일관성 유지
- 배포 자동화 쉽다 (CI/CD 연계 가능)
- DockerFile을 이용해서 한 번에 환경 정의하고 어디서든 동일하게 실행 가능

#### 정리
- Docker는 환경 설정을 한 번만 하면 어디서든 동일하게 실행 가능
- VM은 서버마다 별도로 설정해야 해서 시간이 오래 걸린다
- Docker는 CI/CD 연계가 쉽지만, VM은 자동화하려면 추가 도구(Ansible, Terraform 등)가 필요하다



