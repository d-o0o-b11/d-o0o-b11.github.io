---
title: 책을 선택한 이유 + 1장 (1-2강)
description: 책을 완독한 후 내가 얻고자 하는 것은?
# author: d_o0o_b
categories: [Reading, SQL-Level-Up]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 책 완독 후 기대하는 내 모습
개발을 하면서 지식과 경험이 쌓일수록 더 나은 코드를 작성하고 싶은 욕심이 생겼습니다.
그중에서도 '성능 개선'은 개발 과정에서 결코 빼놓을 수 없는 중요한 요소라는 것을 깨달았습니다.

SQL을 작성할 때 단순히 원하는 결과를 얻는 것이 아니라 효율성과 성능을 고려하며 작성해야 한다는 점을 인식하게 되었습니다.
그동안 저는 DBMS를 마치 블랙박스처럼 다루어 왔습니다. 하지만 데이터의 양이 많아질수록 이러한 방식에는 한계가 따른다고 생각합니다.

따라서 이 책을 통해 블랙박스의 뚜껑을 열어 내부를 깊이 이해하고 이를 화이트박스로 만들어 나가는 것을 목표로 하고 있습니다.


## 1강: DBMS 아키텍처 개요

### 쿼리 평가 엔진 ⭐️
사용자가 입력한 SQL 구문을 분석하고 어떤 순서로 데이터를 조회할지를 결정하는 역할을 한다.
이 과정에서 실행 계획(Execution Plan) 을 수립하며 데이터를 접근하는 방식을 접근 메서드(Access Method) 라고 한다.
즉, 쿼리 평가 엔진은 SQL 실행 전략을 세우고 실행하는 DBMS의 핵심 모듈이다.


### 버퍼 매니저
DBMS는 데이터를 빠르게 처리하기 위해 버퍼(Buffer) 라는 메모리 공간을 사용한다.
버퍼 매니저는 이 메모리를 관리하며 디스크에서 데이터를 읽어올 때 최대한 메모리에서 처리하도록 돕는다.
버퍼 매니저는 디스크 용량 매니저와 협력하여 작동하며 디스크 I/O를 줄여 성능을 최적화하는 중요한 역할을 한다.


### 디스크 용량 매니저 
DBMS는 데이터를 영구적으로 저장하는 시스템이다.
웹 서버나 애플리케이션 서버는 실행되는 동안만 데이터를 저장하면 되지만 DBMS는 데이터를 디스크에 안전하게 보관해야 한다.
디스크 용량 매니저는 데이터가 어디에 저장될지 결정하고 읽고 쓰는 과정을 관리하는 역할을 한다.


### 트랜잭션 매니저와 락 매니저
상용 시스템에서 데이터베이스를 사용하는 사람은 한 명이 아닙니다. 여러 사람이 동시에 데이터베이스에 접근해서 사용하게 되는데, 이때 각각의 처리는 DBMS 내부에서 트랜잭션이라는 단위로 관리됩니다. 이러한 트랜잭션의 정합성을 유지하면서 실행시키고 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 것이 트랜잭션 매니저와 락 매니저의 역할입니다.

데이터베이스는 여러 사용자가 동시에 접근하여 데이터를 처리한다.
이때, 각각의 작업은 트랜잭션(Transaction) 단위로 관리되며 데이터 정합성을 유지해야 한다.

- 트랜잭션 매니저: 트랜잭션이 정상적으로 실행되도록 관리
- 락 매니저: 여러 사용자가 동일한 데이터에 접근할 때 충돌을 방지하기 위해 락(Lock)을 설정

여러 사용자가 동시에 같은 데이터를 변경하려 할 때 충돌을 방지하고 일관성을 유지하는 역할을 한다.

> 이 책에서는 단일 SQL 성능을 중심으로 설명하며 다중 사용자 환경에서 발생하는 동시성 문제는 다루지 않는다.
{: .prompt-info }


### 리커버리 매니저
DBMS는 중요한 데이터를 저장하기 때문에 데이터 손실이 발생하면 치명적이다.
이를 방지하기 위해 정기적인 백업과 복구 기능을 수행하는 것이 리커버리 매니저이다.

- 예상치 못한 장애(서버 다운, 전원 차단 등) 발생 시 데이터 복구
- 트랜잭션이 비정상적으로 종료되었을 때 데이터의 일관성을 유지


## 2강: DBMS와 버퍼
> DBMS의 버퍼 매니저가 어떤 기능을 수행하는지 알아보자

DBMS의 성능에 큰 영향을 미치는 요소 중 하나가 버퍼(Buffer) 이다.
메모리는 한정된 자원이지만 데이터베이스가 저장해야 할 데이터는 방대하기 때문에 데이터를 버퍼에 어떤 식으로 확보할 것인가 하는 부분에서 트레이드오프가 발생한다.


[기억장치 계층 이미지]

기억장치는 기억 비용(저장 비용) 에 따라 계층 구조로 나뉜다.

- 메모리(RAM): 빠르지만 용량이 제한적이고 비용이 높음
- 하드디스크(HDD): 대용량 저장이 가능하지만 속도가 느림

데이터를 많이 저장하려면 속도를 희생해야 하고 속도를 높이려면 저장 용량을 줄여야 하는 트레이드오프가 존재한다. ⭐️⭐️


### DBMS와 기억장치의 관계
DBMS는 데이터 저장을 목적으로 하는 미들웨어입니다. 데이터를 효율적으로 저장하고 관리하기 위해 하드디스크와 메모리를 함께 사용한다.

1. 하드디스크 (HDD)
    - 대부분의 DBMS가 데이터를 저장하는 기본 매체
    - 2차 기억장치로 속도는 느리지만 용량이 크고 비용이 저렴함
    - 범용적인 데이터베이스 시스템에서 가장 적합한 저장 매체

    > 데이터베이스는 대부분의 시스템에서 범용적으로 사용되는 미들웨어이므로 어떤 상황(또는 관점)에서도 평균적인 수치를 가지는 매체를 선택하는 것이 자연스럽습니다.
    {: .prompt-info }

    - 하지만, DBMS가 모든 데이터를 디스크에만 저장하면 속도가 느려지므로 메모리를 적극적으로 활용한다.


2. 메모리
    - 1차 기억장치로 속도가 매우 빠르지만 용량이 제한적이고 비용이 높음
    - 일반적인 데이터베이스 서버에서는 수십~수백 GB 정도의 메모리를 탑재
    - 모든 데이터를 메모리에 올리는 것은 불가능, 하지만 일부 데이터를 올려서 속도를 높임


### 버퍼와 성능 향상

DBMS는 자주 사용하는 데이터를 메모리에 저장하여 디스크 접근을 줄인다.

- 디스크 접근을 최소화하면 SQL 실행 속도가 크게 향상됨
- **대부분의 SQL 실행 시간은 저장소 I/O(디스크 읽기/쓰기)에 소요**되므로 디스크 사용을 줄이는 것이 중요

이처럼 성능을 향상시키기 위해 데이터를 저장하는 메모리를 버퍼(Buffer) 또는 캐시(Cache) 라고 한다.

- 버퍼: 사용자와 저장소 사이에서 디스크 접근을 줄여주는 역할 (완충제 역할)
- 캐시: 데이터 전송 지연을 줄이는 역할

DBMS의 버퍼 매니저는 "어떤 데이터를 메모리에 얼마나 오래 유지할지"를 결정하여 성능을 최적화하는 역할을 한다.


### 메모리 위에 있는 두 개의 버퍼
DBMS가 데이터를 효율적으로 관리하기 위해 사용하는 메모리는 크게 두 가지 종류로 나뉜다.

- 데이터 캐시(Data Cache)
- 로그 버퍼(Log Buffer)

이 두 가지는 디스크의 느린 속도를 보완하기 위해 존재하며, 성능 최적화에 중요한 역할을 한다.


1. 데이터 캐시
    자주 사용하는 데이터를 메모리에 유지하여 디스크 접근을 최소화하는 메모리 영역이다.

    - 데이터 캐시에 원하는 데이터가 있다면 → 빠르게 응답 가능 (디스크 접근 없음)
    - 데이터 캐시에 없다면 → 디스크에서 데이터를 가져와야 하므로 속도가 느려짐

    데이터 캐시는 SQL 실행 속도를 높이기 위한 핵심적인 메모리 영역이다.

2. 로그 버퍼
    갱신 작업(INSERT, DELETE, UPDATE, MERGE)과 관련된 버퍼로 데이터를 즉시 디스크에 반영하지 않고 로그 버퍼에 먼저 기록한 후 나중에 저장소에 반영하는 방식을 사용한다.

#### 즉시 디스크에 반영하지 않는 이유
- 디스크에 데이터를 직접 변경하면 속도가 느려짐 → 사용자가 대기해야 함
- 로그 버퍼에 먼저 기록하면 빠르게 응답 후, 내부적으로 디스크 변경을 처리 가능

DBMS는 갱신 작업을 비동기 방식으로 처리하여 성능을 최적화한다.


### DBMS는 "저장소의 느림을 어떻게 보완할 것인가"를 고민해온 미들웨어
DBMS는 느린 디스크 속도를 극복하기 위해 다양한 버퍼 메커니즘을 발전시켜왔다.

- 데이터 검색 시 → 데이터 캐시 활용
- 데이터 갱신 시 → 로그 버퍼 활용

만약 저장소 속도가 충분히 빨랐다면 이러한 복잡한 구조는 필요하지 않았을 것이다.
그러나 현실적으로 디스크 속도는 여전히 느리기 때문에 DBMS는 버퍼를 적극적으로 활용하여 성능을 극대화하는 시스템이 되었다.


### 메모리의 성질이 초래하는 트레이드오프
메모리는 속도가 빠르지만 몇 가지 중요한 단점이 있다. 이 단점들이 성능과 데이터 정합성 사이의 트레이드오프를 초래한다.

#### 휘발성 (Volatility)
메모리는 전원이 꺼지면 저장된 데이터가 사라지는 휘발성 저장장치다.

- DBMS를 종료하거나 장애가 발생하면 버퍼에 있던 데이터가 모두 손실됨
- 따라서 메모리가 저렴해진다 해도 영속성이 없는 이상 디스크를 완전히 대체할 수 없음

#### 휘발성의 문제점: 데이터 정합성 이슈
휘발성 때문에 일부 데이터는 손실되어도 괜찮지만 일부 데이터는 절대 손실되면 안 된다.

1. 데이터 캐시의 경우 → 문제 없음
    - 캐시에 있던 데이터가 사라져도 디스크에 원본 데이터가 남아 있음
    - 디스크에서 다시 읽어오면 되므로 응답 속도가 느려질 뿐 데이터 정합성 문제는 없음

2. 로그 버퍼의 경우 → 심각한 문제 발생 가능
    - 장애 발생 시, 디스크에 반영되지 않은 로그 데이터가 완전히 손실됨
    - 사용자가 수행한 갱신(INSERT, UPDATE 등)이 사라질 수 있음
    - ex. 은행 거래, 카드 결제 내역이 유실된다면? → 심각한 비즈니스 문제 발생

#### DBMS의 해결 방법: 커밋 시 로그 파일에 저장
DBMS는 갱신 정보를 로그 버퍼에 먼저 기록한 후, 특정 시점에 디스크에 반영하는 비동기 처리 방식을 사용한다.
그러나 장애 발생 시 로그 버퍼의 데이터가 손실될 위험이 있다.

이를 방지하기 위해 커밋(commit) 시점에 반드시 로그 정보를 디스크에 저장한다.

- 커밋(commit) = 갱신 처리를 확정하는 작업
- 커밋된 데이터는 반드시 디스크에 저장 → 장애 발생 시에도 데이터 복구 가능
- 커밋 떄는 반드시 디스크에 동기 접근

#### 성능 vs 데이터 정합성: 또 다른 트레이드오프
커밋 시 디스크에 데이터를 저장(동기 처리) 하면 데이터 정합성은 높아지지만, 속도는 느려진다.

- 정합성을 보장하려면 → 디스크 동기 접근 필요 → 성능 저하 발생
- 성능을 높이려면 → 비동기 처리 강화 → 데이터 유실 가능성 증가

DBMS는 데이터 정합성과 성능 사이에서 균형을 맞추는 방식을 선택해야 한다.


### 시스템 특성에 따른 트레이드오프
DBMS는 검색과 갱신 중 어떤 작업을 더 중요하게 처리할지에 따라 메모리 자원을 배분한다.
하지만 메모리는 한정된 자원이므로 데이터 캐시와 로그 버퍼의 크기를 어떻게 조정할지가 성능 최적화의 핵심이 된다.

#### 데이터 캐시 vs. 로그 버퍼: 왜 크기가 다를까?
DBMS를 살펴보면 데이터 캐시는 크지만 로그 버퍼는 상대적으로 매우 작다.

- 예를 들어, Oracle과 PostgreSQL의 기본 로그 버퍼 크기는 1MB도 되지 않는다.
- 이렇게 작은 로그 버퍼로도 괜찮을까? → DBMS는 검색을 더 중요하게 여기기 때문!

1. DBMS는 기본적으로 검색이 주요 작업이라고 가정
    - 검색 대상 레코드는 수백만~수천만 건까지 될 수 있음
    - 하지만 트랜잭션당 갱신되는 레코드는 보통 한 건~수만 건 수준
    - 따라서 검색 성능을 높이기 위해 데이터를 캐시에 많이 올리는 것이 더 유리하다.

2. 메모리가 충분하다면? → 데이터 캐시를 최대한 크게 할당하는 것이 일반적
    - 대부분의 DBMS는 메모리가 남아 있다면 데이터 캐시를 키우도록 권장
    - 반면, 로그 버퍼는 갱신 처리량이 많은 시스템이 아니라면 크게 할당할 필요 없음


하지만, 이 설정이 모든 시스템에 적합한 것은 아니다!

갱신이 많은 시스템이라면? → 로그 버퍼 크기를 늘리는 튜닝이 필요

따라서, 시스템 특성에 맞춰 로그 버퍼와 데이터 캐시 크기를 조정해야 한다.

#### 검색 vs 갱신 
메모리는 한정된 자원이므로 검색과 갱신 중 우선순위를 정해야 한다.

- 메모리가 충분하다면? → 데이터 캐시와 로그 버퍼 모두 충분히 할당
- 메모리가 부족하다면? → 검색 성능을 높이기 위해 데이터 캐시를 우선적으로 키우는 것이 일반적

즉,

- 로그 버퍼 크기가 크다면? → 갱신 부하가 많은 시스템
- 데이터 캐시 크기가 크다면? → 검색 부하가 많은 시스템

따라서, DBMS가 어떤 기준으로 리소스를 배분하는지 이해하고 시스템 특성에 맞게 조정하는 것이 필수적이다!


### 추가적인 메모리 영역 '워킹 메모리'
DBMS는 데이터 캐시와 로그 버퍼 외에도 '워킹 메모리(Working Memory)'라는 추가적인 메모리 영역을 사용한다.
이 영역은 정렬(Order By), 집합 연산, 윈도우 함수, 해시 결합 등의 작업을 수행할 때 활용된다.

#### 워킹 메모리는 언제 사용될까?
1. 워킹 메모리는 정렬 및 해시 연산을 처리하기 위한 작업용 메모리 영역이다.
    - ORDER BY, 윈도우 함수, 집합 연산 등에 사용됨
    - 해시 결합(hash join) 등 테이블 조인 시 활용됨

2. DBMS마다 워킹 메모리를 관리하는 방식이 다름
    - 일부 DBMS는 워킹 메모리를 데이터 캐시, 로그 버퍼와 별도로 관리
    - SQL 실행 중에 필요할 때 할당되고, 작업이 끝나면 해제됨

3. 워킹 메모리가 부족하면? → 디스크(저장소)를 사용하게 됨
    - 메모리가 부족하면 임시 저장소(temporary storage)를 사용
    - OS의 스왑(swap) 개념과 비슷
    - 저장소 접근은 메모리보다 훨씬 느리므로 성능이 급격히 저하됨

#### 워킹 메모리가 부족하면 어떤 일이 일어날까?
워킹 메모리가 부족하면 SQL 실행 속도가 급격히 느려질 수 있다.

1. 속도 저하 발생
    - 메모리 내에서 실행될 때는 빠르게 처리되지만 메모리가 부족해 저장소를 사용하게 되면 갑자기 속도가 느려짐
    - DBMS가 실행 중에 성능이 들쭉날쭉해지는 이유 중 하나

2. 여러 SQL 구문이 동시에 실행되면 문제 발생 가능
    - 개별 SQL 실행 시에는 문제가 없어도 여러 SQL이 동시에 실행되면 워킹 메모리가 부족할 수 있음
    - 따라서 부하 테스트를 통해 동시 실행 시의 성능도 확인하는 것이 중요

#### DBMS는 왜 워킹 메모리가 부족해도 중단하지 않을까?
1. DBMS는 메모리가 부족해도 SQL 실행을 포기하지 않는다.
    - 메모리 부족 시 속도는 느려지지만 SQL 구문이 오류를 발생시키지 않도록 설계됨
    - 이는 DBMS가 운영체제(OS)처럼 안정적인 데이터 처리를 목표로 하기 때문

2. DBMS의 철학: "느려지더라도 끝까지 처리하자!"
    - 만약 DBMS가 메모리가 부족할 때 SQL 실행을 중단하도록 설계되었다면?
        - 일부 SQL 구문이 오류를 발생시키면서 실행되지 않을 위험이 커짐

따라서, DBMS는 비록 성능이 저하되더라도 어떻게든 처리를 끝내는 방식을 선택




