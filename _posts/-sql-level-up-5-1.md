---
title: 5장 정리 - (15강(2)-완강)
description: 반복문
# author: d_o0o_b
categories: [Reading, SQL-Level-Up]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 15강: 반복계의 공포
### 반복계를 빠르게 만드는 방법은 없을까?
시스템에서 반복계로 인해 성능 문제가 발생했다면 다음 세 가지 방법 중 하나를 고려할 수 있다.

#### 1. 반복계를 포장계로 다시 작성
이는 애플리케이션을 직접 수정해야 하는 접근이다. 현실적으로는 컷오버 직전에 성능 문제가 드러나 이런 제안이 나올 경우, 수용하기 어렵다. 하지만 이론적으로는 가장 근본적인 해결책이 될 수 있다.

#### 2. 각각의 SQL을 빠르게 수정
단순한 SQL을 조금씩 튜닝해 성능을 개선하려는 방식이다. 하지만 반복계에서 사용하는 SQL 대부분은 단순한 유니크 스캔이나 인덱스 레인지 스캔 형태이기 때문에 튜닝 여지가 크지 않다. 특히 반복 INSERT의 경우, SELECT보다 더 어렵고 기대할 수 있는 효과도 제한적이다.

#### 3. 다중화 처리
현실적으로 가장 많이 쓰이는 대안이다. CPU나 디스크 등 리소스가 충분하고, 데이터 분할 키가 있다면 다중화 처리를 통해 선형적인 성능 향상을 꾀할 수 있다. 다만, 약간의 애플리케이션 수정은 필요하며, 분할 키가 없거나 순서가 중요한 경우에는 적용이 어렵다.

---

반복계는 튜닝 방법이 제한적이다. 반복계 기반 애플리케이션의 성능이 느리다면, 구조 자체를 바꿔야 할 수도 있다. 하지만 반복 횟수가 수백 회 수준이라면 반복계도 충분한 성능을 낼 수 있으므로, 무조건 반복계를 배제할 필요는 없다. 다만 일괄 처리와 같이 수백만~수천만 회 반복되는 환경에서는 반드시 주의가 필요하다. 특히 프레임워크나 패키지 내부에서 반복계가 사용된 경우에는 수정이 더 어려워진다.

### 반복계의 장점
반복계는 비효율적이라 평가받는 경우가 많지만 다음과 같은 장점이 있다.

#### 실행 계획의 안정성
반복계는 기본 키 기반의 단순한 SQL을 사용하므로 실행 계획이 안정적이다. 조인이 포함되지 않아 실행 도중 갑작스러운 계획 변경이나 성능 저하 가능성도 낮다. 반면 포장계는 복잡한 SQL을 사용하기 때문에 계획 변동성이 존재하며, 이 점이 단점이 될 수 있다. 따라서 복잡한 SQL을 사용할 때는 힌트 구문이나 단순화 전략을 병행하는 것이 좋다.


#### 예상 처리 시간의 정밀도
반복계는 실행 시간의 예측이 쉬운 편이다.

>처리 시간 = 1회 실행 시간 × 실행 횟수

형식으로 계산 가능하며, 예측도 비교적 정밀하다. 

반면 포장계는 실행 계획에 따라 처리 시간이 유동적이므로 예측이 어렵다. 샘플 데이터를 이용한 테스트와 선형성 분석이 도움이 된다.


#### 트랜잭션 제어의 용이성
반복계는 일정 횟수마다 커밋을 수행할 수 있어 장애 발생 시 부분 재처리가 가능하다. 포장계는 하나의 SQL로 대량 작업을 처리하기 때문에 중간 실패 시 전체 롤백이 필요하다.


## 16강: SQL에서는 반복을 어떻게 표현할까?
### 반복 대신 사용하는 SQL의 도구
SQL에서 반복을 표현할 수 있는 핵심 도구는 CASE 식과 윈도우 함수이다. CASE 식은 절차 지향 언어의 IF-THEN-ELSE 구문에 해당하며, 반복문 내부에서 자주 사용되는 조건문 역할을 한다. 이 둘은 세트로 생각하면 이해하기 쉽다.

#### SIGN 함수
숫자 값의 부호를 판단해 -1, 0, 1 중 하나를 반환하는 함수이다. 조건식을 단순화할 때 유용하며, 윈도우 함수의 반복 사용을 줄이는 데에도 활용된다.

#### ROWS BETWEEN 옵션
윈도우 함수의 레코드 범위를 제한하는 옵션이다. 예를 들어 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING은 직전 한 개 레코드만을 대상으로 한다.

#### 상관 서브쿼리
외부 쿼리와 내부 쿼리 간의 결합 조건을 사용하는 서브쿼리이다. PARTITION BY, ORDER BY와 유사한 기능을 수행하지만, 복잡한 실행 계획과 성능 리스크가 수반된다. 두 번째 이상 레코드를 가져오는 데는 적합하지 않다.


### 최대 반복 횟수가 정해진 경우
반복 없이 문제를 해결할 수 있는 구조에서는 CASE 식 + 윈도우 함수 조합이 가장 강력하다.

예: 인접 우편번호 찾기
정렬을 추가로 사용하므로 비용이 들지만, 테이블 풀 스캔을 피하는 효과가 더 크다.

### 반복 횟수가 정해지지 않은 경우
책의 예제를 참조하여 다양한 방법으로 처리할 수 있다.

## 17강: 바이어스의 공죄
5장을 마무리하며, 반복계가 많은 시스템의 현실을 되짚어보게 된다. 책에서는 반복계 의존을 병으로 표현했지만, 반복계에도 분명 장점은 있다. 절차 지향적 사고방식에서 집합 지향적 사고로의 전환을 강조하기 위해 병이라는 용어를 사용한 것이다.

인간은 누구나 바이어스를 가지고 있다. 반복계에 의존하는 사고도 일종의 바이어스이다. 절차 지향형 언어는 대부분 파일을 열고, 레코드를 한 줄씩 읽고, 로직을 적용한 후 파일을 닫는 순서로 이루어진다. 이는 강력한 모델이며, 많은 문제에 적용 가능한 ‘망치’와 같은 존재다. 그래서 사람들은 종종 반복을 최선의 해결책처럼 여긴다.

그러나 SQL은 이러한 절차 지향적 사고로부터의 탈출을 목적으로 설계된 언어이다. DBMS 내부는 절차적으로 동작하더라도, SQL은 이를 은폐하여 추상화된 집합 연산을 제공한다. 집합 지향 사고방식 없이는 SQL을 제대로 활용할 수 없다. 반복계는 익숙한 사고방식으로 문제를 풀 수 있게 해주는 도구지만, 고성능 RDB 설계를 위해서는 반복계에 대한 의존을 벗어나는 것이 필요하다.

