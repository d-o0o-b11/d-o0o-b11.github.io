---
title: 백엔드 구조
description: 여러 아키텍처 중 Vertical Slice + CQRS를 선택하게 된 이유와 적용 후기
# author: d_o0o_b
categories: [Minime]
tags: [typography]
# pin: true
math: true
mermaid: true
---


## 개요

아키텍처에 관심을 가지게 된 계기는 개발 1년 차 때였습니다.  
**“기능이 늘어날수록 구조가 복잡해지는데 어떤 기준으로 파일과 폴더를 나눠야 유지보수가 쉬울까?”**의 고민이 자연스럽게 **아키텍처에 대한 관심**으로 이어졌습니다.

혼자 개발을 하더라도 시간이 지나면 **구조가 엉켜서 코드를 찾기 어렵고 유지보수도 힘들어지기 마련입니다.**  
팀 프로젝트에서는 이러한 문제가 훨씬 더 크게 다가옵니다.

그래서 저는 여러 아키텍처를 직접 도입해보며 **가독성과 확장성의 균형**이 잘 맞는 구조를 고민했습니다.      
현재는 **CQRS + Vertical Slice Architecture**를 사용하고 있습니다.

<br/>

## 그동안 적용해본 아키텍처

아래는 그동안 적용해본 아키텍처들입니다.  
각 구조의 장단점, 도입에 적합한 상황에 대해 정리해두었습니다.

- [계층형 아키텍처 (3-Layer Architecture)](http://d-o0o-b11.github.io/posts/3-layer-architecture/)
- [클린 아키텍처 (Clean Architecture)](http://d-o0o-b11.github.io/posts/clean-architecture/)
- [헥사고날 아키텍처 (Hexagonal Architecture)](http://d-o0o-b11.github.io/posts/hexagonal-architecture/)
- [Vertical Slice Architecture](http://d-o0o-b11.github.io/posts/vertical-slice-architecture/)

<br/>

## 왜 CQRS + Vertical Slice를 선택했는가?

NestJS의 기본 계층형 아키텍처를 시작으로 클린 아키텍처와 헥사고날 구조까지 경험했지만 각 구조에는 나름의 장단점이 있었습니다.

하지만 아무리 이상적인 구조라도 **읽기 어렵고 유지보수에 불편**하다면 잘못된 선택입니다.

그래서 저는 **기능 단위로 코드를 찾기 쉬울 것**, **읽기와 쓰기를 명확히 분리해 의도가 드러날 것**, **복잡한 구조 없이도 확장성과 테스트가 편리할 것**을 기준으로 구조를 개선하였습니다.

이 기준에 가장 부합한 구조가 **CQRS + Vertical Slice Architecture**였습니다.


<br/>

## 이 구조의 만족스러웠던 점

#### 로직의 의도가 명확하게 드러납니다.
Handler, Command, DTO 등이 기능 단위로 모여 있어 어떤 작업을 처리하는 코드인지 한눈에 파악할 수 있습니다.  
기능별로 파일이 분리된 구조보다 직관적입니다.

---

#### 테스트가 쉬워졌습니다.
하나의 Slice 단위로 테스트가 가능하고 의존성도 명확합니다.  
복잡한 의존성 주입이나 설정 없이 단일 기능 단위로 격리된 테스트를 작성할 수 있습니다.  
특히 CQRS 특성상 Command/Query를 분리하여 읽기/쓰기 테스트도 독립적으로 구성할 수 있습니다.

---

### 신규 기능 추가 시 빠르게 온보딩할 수 있습니다.
구조가 직관적이라 새로운 개발자도 어디서부터 작업해야 할지 빠르게 파악할 수 있습니다.  
"새로운 기능을 추가하려면 → Handler + Command/Query + DTO를 만든다"는 일정한 패턴이 있어 진입 장벽이 낮고 코드 작성이 규칙적입니다.  
팀 규모가 커질수록 이 점이 유리하게 작용합니다.

---

<!-- ### REST, gRPC, GraphQL 등 다양한 I/O에 유연하게 대응 가능합니다.
핸들러와 DTO만 적절히 분리해주면 다양한 API 스타일에도 쉽게 대응할 수 있습니다.  
핵심 로직은 그대로 두고 **입력 방식에 따라 경량 어댑터만 바꾸면 되는 구조**입니다.  
같은 도메인 로직을 여러 I/O에서 재사용하기 좋습니다.

--- -->

### 점진적인 마이크로서비스 전환도 수월합니다.
Slice 단위로 도메인이 분리되어 있기 때문에 특정 기능만 별도의 서비스로 분리하기 쉽습니다.  
기존 모놀리식 코드베이스에서 특정 Slice를 떼어내어 독립적으로 배포하거나 도메인 경계를 명확히 하여 MSA 전환 초기 비용을 줄일 수 있습니다.

<br/>

## 느낀점
> 아키텍처는 정답이 아니라 선택입니다.
{: .prompt-info }

그 선택은 개발자의 경험, 팀의 규모, 시스템의 복잡도에 따라 언제든 달라질 수 있습니다.  
지금은 **CQRS + Vertical Slice**가 가장 잘 맞지만 도메인이 복잡해지고 팀이 커진다면 다시 구조를 바꿀 수도 있을 것입니다.

중요한 건 **현재의 문제를 가장 잘 해결할 수 있는 구조를 선택하고** 필요에 따라 유연하게 진화시킬 수 있어야 한다는 점입니다.