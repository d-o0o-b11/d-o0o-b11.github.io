---
title: 프론트 코드 정리
description: 백엔드 개발자의 프론트 삽질기
# author: d_o0o_b
categories: [Minime]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 백엔드 개발자의 프론트 삽질기

React Native를 처음 접했을 때, 일단 되는 대로 코드를 썼습니다. 🫣
한 파일 안에 `axios`, `fetch`, `useEffect`, `useState`, `useRef` 다 넣고, 스타일도 그냥 아래에 쭉 작성하였습니다.

> 그땐 몰랐습니다..이게 훗날 제 발목을 잡을 줄이야 (멈춰 과거야)

처음에는 **감**을 잡는 게 최우선이라 생각했습니다. 한 화면 안에서 동작만 되면 그걸로 만족했습니다.
그런데 어느 순간부터 코드의 양이 많아지고 가독성이 급격하게 떨어지기 시작했습니다.

그래서 1차 MVP 기능 틀을 얼추 잡아둔 상태에서 구조적인 리팩토링을 진행했습니다.


### 리팩토링 시작: 컴포넌트화와 폴더 분리

처음엔 모든 코드를 한 파일에 다 몰아넣었는데 너무 보기 힘들고 디버깅도 어려웠습니다.  
그래서 다음과 같이 구조를 개선했습니다.

1. **UI 단위를 쪼개서 컴포넌트화**  
   버튼, 모달, 카드, 리스트 등 반복되는 UI 요소를 전부 컴포넌트로 분리했습니다.  
   덕분에 중복 코드도 줄고 재사용성을 높일 수 있었습니다.

2. **API 요청 로직 분리**  
   `api.ts` 파일로 따로 분리해서 서버와의 통신 로직을 한곳에서 관리했습니다.  
   이렇게 하니 `try-catch`도 공통 처리할 수 있어서 훨씬 깔끔하게 사용할 수 있게 되었습니다.

3. **타입 명시**  
   처음에는 타입을 any로 사용하거나 명시를 하지않았습니다. 그러다보니 코드를 다시 볼때 마다 해당 변수가 어떤 값을 담고 있는지, 무엇을 반환하는지를 계속 추적해야 하는 시간이 아까웠습니다. 그래서 서버 응답, 컴포넌트 props 전부 타입을 명시해서 보다 편하게 값들을 바로바로 사용할 수 있었습니다. 이 후에는 타입을 먼저 정의하고 구현을 먼저 하는게 베스트인거같습니다. 

4. **폰트도 컴포넌트로**  
   Text 스타일이 반복되다 보니 커스텀 Text 컴포넌트를 만들었습니다. `size`, `color` 등만 넘겨주면 디자인 시스템에 맞춰 자동으로 스타일이 적용되는 컴포넌트입니다. 깔끔하고, 일관되고, 디자이너와의 커뮤니케이션도 쉬워졌습니다.



### 리팩토링 후 느낀 점

- 코드의 가독성이 올라갔습니다.
- 로직을 파악하는 데 걸리는 시간이 줄었습니다.
- 서버 통신, 스타일 등 재사용 가능한 로직을 한곳에서 관리할 수 있어 훨씬 효율적이었습니다.



### 사용한 React 훅들 정리

- `useState` 
  컴포넌트 내부에서 **상태를 저장**하는 가장 기본적인 훅  <br/>
  버튼 클릭 여부, 입력값 등 사용자와의 상호작용을 저장하는 데 유용했습니다.

- `useEffect`  
  컴포넌트의 생명주기에 따라 특정 작업을 수행할 수 있도록 도와주는 훅 <br/>
  API 요청, 바텀시트 제어 로직을 처리할 때 사용했습니다.

- `useRef` 
  렌더링과 무관하게 값을 저장할 수 있는 훅  <br/>
  바텀시트 제어 로직을 처리할 때 사용했습니다.



### fetch vs axios
서버 요청을 할 때 `fetch`를 사용할지 `axios`를 사용할지 고민하였습니다.

| 항목         | fetch                         | axios                            |
|--------------|-------------------------------|-----------------------------------|
| 기본 제공     | 브라우저 내장 API             | 외부 라이브러리 설치 필요        |
| 응답 처리     | `res.json()` 등 직접 파싱     | 자동으로 JSON 파싱               |
| 에러 처리     | 200이 아니어도 에러 아님       | 상태코드 기준으로 에러 throw     |

<!-- | 인터셉터 등 고급 기능 | ❌ (직접 구현해야 함)       | ✅ (인터셉터, 취소 토큰 등 제공) | -->

fetch도 충분히 쓸만했지만, axios 쪽이 기능적으로 더 유연하고 실용적이라는 생각이 들었습니다.

현재는 fetch로 통일해서 사용 중이지만 여유가 생기면 axios 기반으로 리팩토링하는 것도 좋은 선택이 될 것 같습니다.

## 마무리
“구조가 생명이다” 라는 걸 이번에 뼈저리게 느꼈습니다. 😇

처음엔 “일단 감부터 잡자! 잠깐만 이렇게 하자!” 라는 생각으로 코드를 짰는데, 일정 규모를 넘어서니까 그 선택이 저 스스로도 원망스러워질 만큼 구조의 중요성이 절실하게 다가왔습니다.

물론 지금의 구조가 완벽하다고는 생각하지 않습니다.
시간이 지나 다시 보면 아쉬운 점들이 눈에 들어올 거라고 생각합니다.

하지만 중요한 건 끊임없이 고민하고 계속해서 나아가려는 태도라고 생각합니다.
앞으로도 구조에 대한 고민을 놓지 않고, 더 나은 코드를 향해 천천히, 꾸준히 나아가겠습니다.
