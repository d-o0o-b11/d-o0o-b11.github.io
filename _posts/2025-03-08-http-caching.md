---
title: HTTP , HTTPS 동작 원리 [3]
description: HTTP 캐싱
# author: d_o0o_b
categories: [Dev-Notes, Theory]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## HTTP 캐싱
HTTP 캐싱은 **불필요한 네트워크 요청을 줄여 웹 페이지 성능을 최적화하는 기술**입니다.


<br/>

### 캐싱 관련 헤더

| 헤더    | 설명 |
| :--------------------------- |:---------------------------|
| Cache-Control  | 캐싱 동작을 제어하는 주요 헤더 (`no-cache`, `max-age=3600`) | 
| ETag | 리소스를 식별하는 해시값, 변경 시 새로운 값 제공됨 | 
| Last-Modified  | 리소스의 마지막 수정 시간 표시, 변경 여부 판단에 사용 | 


<br/>

### 브라우저 캐싱 vs 서버 캐싱: 목적과 효율성 측면
#### 브라우저 캐싱 (Client-side Caching)
브라우저 캐싱은 **클라이언트 측에서 정적 리소스를 저장**해두고 동일한 요청 시 로컬에서 바로 불러오는 방식입니다. 이미지, CSS, JS 등 자주 바뀌지 않는 자원을 재요청 없이 사용할 수 있어 **응답 속도 개선**에 효과적입니다.
- ex. `Cache-Control` 헤더로 브라우저에 캐싱 정책을 전달합니다.


##### 적합 대상
- 변경이 드문 정적 리소스 (이미지, CSS, JS)
- 구조가 자주 바뀌지 않는 페이지  
- 변동이 적은 API 응답

##### 장점
- **빠른 응답**: 파일을 로컬에서 불러오므로 로딩 속도가 빨라집니다.
- **서버 부하 감소**: 동일 리소스를 반복 요청하지 않아 서버 리소스를 절약합니다.
- **트래픽 절감**: 네트워크 요청이 줄어들어 대역폭을 아낄 수 있습니다.
- **별도 인프라 비용 없이 적용 가능**: 별도 인프라 없이 브라우저 자체 기능으로 캐싱 가능합니다.

##### 단점
- **버전 관리 필요**: 만료 기간이나 캐시 버전을 적절히 설정하지 않으면 오래된 데이터를 불러올 수 있습니다.
- **보안 우려**: 민감한 정보가 캐시되면 다른 사용자가 접근할 위험이 있습니다.
- **동적 콘텐츠에 부적합**: 사용자마다 다른 데이터나 자주 바뀌는 콘텐츠에는 적절하지 않습니다.

<br/>

#### 서버 캐싱 (Server-side Caching)
서버 캐싱은 **서버나 중간 캐시 서버(CDN, Redis 등)** 에서 데이터를 저장해두고 동일 요청 시 빠르게 응답하는 방식입니다. 동적 콘텐츠, DB 조회 결과, 복잡한 계산 결과 등 **리소스를 많이 소모하는 작업**에 유용합니다.
- ex. Cloudflare, Redis 등을 활용한 서버 캐시


##### 적합 대상
- 자주 조회되는 DB 데이터
- 계산 비용이 높은 결과 (ex. 통계, 추천 결과)
- 사용자의 요청에 따라 생성되는 동적 콘텐츠

##### 장점
- **빠른 응답**: DB나 계산을 생략하고 바로 응답 가능합니다.
- **서버 부하 감소**: 동일 요청을 반복 처리하지 않아 CPU, DB 비용을 절약할 수 있습니다.
- **비용 절감**: 트래픽 감소 + 데이터베이스 사용량 감소
- **유연한 전략**: TTL(유효 시간), LRU(가장 오래된 항목 삭제) 등 상황 맞춤 캐싱이 가능합니다.


##### 단점
- **메모리 사용**: Redis 등은 메모리 기반이므로 캐시 용량이 클수록 비용 증가합니다.
- **무효화 관리 필요**: 캐시된 데이터가 갱신되지 않으면 일관성 문제가 발생합니다.
<!-- - 복잡한 관리: 서버 캐싱을 제대로 관리하지 않으면 데이터의 일관성 문제가 발생할 수 있습니다. 예를 들어, 데이터가 갱신되었을 때 캐시를 무효화해야 하는데 이를 제대로 관리하지 않으면 오래된 데이터가 반환될 수 있습니다. -->
<!-- - 비용 문제: Redis와 같은 메모리 기반 캐시 시스템은 고용량의 데이터를 캐시하려면 많은 메모리가 필요합니다. 메모리 비용이 증가할 수 있으며 캐시 데이터를 너무 많이 저장하면 서버의 성능 저하나 다운타임을 초래할 수 있습니다. -->
- **운영 복잡성**: 캐시 전략 설계, 동기화 등 고려할 요소가 많습니다.

<br/>

### CDN/프록시 서버 vs Redis

#### CDN/프록시 서버 (예: Cloudflare, Varnish)
- 정적 리소스(이미지, CSS, JS 등)를 캐싱  
- 전 세계 분산 서버를 통해 빠른 응답 제공  
- 서버 부하 및 트래픽 감소에 효과적


#### Redis/Memcached
- DB 조회 결과나 계산 비용이 큰 데이터를 메모리에 저장  
- 사용자 요청에 빠르게 응답 가능  
- TTL, LRU 등 유연한 캐싱 전략 설정 가능


##### 용어
- **TTL(Time To Live)**: 일정 시간이 지나면 캐시가 자동 만료
- **LRU(Least Recently Used)**: 가장 오래 사용되지 않은 데이터부터 제거


<br/>


### 비용 측면에서의 고려사항
- **Redis**는 메모리 기반 캐시이기 때문에 데이터 양이 많아질수록 비용이 커질 수 있습니다.  
  → 하지만 자주 요청되는 데이터를 캐싱해 **DB 부하와 서버 비용을 줄이는 효과**가 큽니다.

- **브라우저 캐싱**은 **별도 인프라 비용 없이도 적용 가능**하므로 정적 리소스나 변경이 적은 API 응답은 브라우저 캐싱으로 처리하는 것이 훨씬 경제적입니다.


<br/>

### 결론
- **정적 리소스**는 브라우저 캐싱을 통해 클라이언트에서 재사용하도록 하여 빠른 로딩과 서버 트래픽 절감 효과를 얻을 수 있습니다.
- **동적 데이터**나 자주 바뀌는 데이터는 서버 캐싱(ex. Redis)을 통해 빠른 응답을 제공하고 DB 부담을 줄여야 합니다.
- 두 캐싱 방식은 서로 보완적이며 **상황에 맞춰 적절히 조합해서 사용하는 것이 최적의 성능을 달성하는 핵심 전략**입니다.



<!-- > 최신 데이터가 중요하다면 `DB → Redis → 클라이언트` 흐름을 잘 설계하는 것이 핵심입니다.
{: .prompt-tip }

> 최신 데이터가 중요하다면 캐시 무효화 시점을 명확히 정의하고,  
> `Redis → (없으면) DB → 클라이언트` 흐름으로 fallback 전략까지 설계하는 것이 핵심입니다. -->


<br/><br/>



> 서버 캐싱만 써봤어서 Redis 같은 시스템만 있는 줄 알았는데 브라우저도 캐싱할 수 있다는 걸 새롭게 알게 되었습니다.
> 응답 헤더에 캐싱 옵션만 잘 설정하면 별도의 Redis 없이도 정적 리소스를 효율적으로 캐싱할 수 있습니다! 😳
> **기회가 된다면 브라우저 캐싱도 꼭 활용해봐야겠습니다.**
{: .prompt-info }