---
title: 바텀 시트
description: 세번째 고난
# author: d_o0o_b
categories: [Minime]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 개요

React Native에서 바텀 시트를 구현하는 과정에서 두 가지 주요 문제를 겪었습니다.

1. 바텀 시트가 탭 위로 올라와야 한다.
2. 바텀 시트에서 TextInput을 사용할 수 있어야 한다.

이번 글에서는 이 문제를 해결하는 과정과 고민했던 부분을 정리해보겠습니다.


## 문제 1. 바텀 시트가 탭을 가려야 한다.

`@gorhom/bottom-sheet` 라이브러리를 사용해서 바텀 시트를 구현하려 했습니다.

하지만 이 라이브러리를 사용할 경우 바텀 시트가 탭보다 아래에서 나타나버리는 문제가 있었습니다. 원하는 건 바텀 시트가 탭을 덮어야 하는 UI였기에 공식 문서의 예제들만으로는 해결할 수 없었습니다.


### 해결 방법
해답은 생각보다 단순했습니다. **`BottomSheetModalProvider`의 위치**가 관건이었습니다. 해당 컴포넌트를 정확한 위치에 배치해야 바텀 시트가 제대로 탭을 덮고 올라오게 됩니다.

[참고한 유튜브 강의](https://youtu.be/oIEykI5oagI?si=917g4yysij1ZbBU1)

### 문제 화면
> 탭 UI를 가리지 못하고 그 위에서 올라오는 바텀 시트

![Image](https://github.com/user-attachments/assets/98620ffa-8e72-4fd2-b888-cbb103b5b609?raw=true){: w='300' }

### 구현해야 하는 화면
![Image](https://github.com/user-attachments/assets/0ed578e9-b307-4010-8eb1-9061d7e609f7?raw=true){: w='400' }

<br/>
<br/>

## 문제 2. 바텀 시트 높이 동적 조정
TextInput이 포함된 UI에서는 키보드가 올라올 때 바텀 시트 높이를 유동적으로 조정해줘야 합니다. 이 부분이 가장 큰 문제였습니다.

### 문제 원인

1. 키보드보다 바텀 시트의 높이가 낮다면 키보드가 올라오지 못합니다.
2. 반대로 바텀 시트 높이를 너무 크게 설정하면 화면의 절반 이상이 불필요한 여백입니다.

### 해결 방법

```
const screenHeight = Dimensions.get('window').height;
const keyboardHeight = useKeyboardHeight();
const sheetHeight = keyboardHeight > 0 ? screenHeight * 0.6 : screenHeight * 0.4;
```

이 방식으로 어느 정도 유동적인 높이 조정이 가능했습니다. 하지만 가끔 바텀 시트 높이 계산이 제대로 반영되지 않거나, 키보드가 정상적으로 올라오지 않는 등 불안정한 경우들이 존재했습니다.


### 문제 화면 
> 높이 100%로 했을 경우 여백 화면 증가

![Image](https://github.com/user-attachments/assets/d7a0e207-d333-40bc-bb36-648efa9a2f04?raw=true){: w='300' }


## 고민거리

1. 라이브러리를 계속 사용할 것인가?
    - 원하는 대로 동작하지 않을 때마다 해결하는 데 시간이 걸린다.
    - 직접 구현하면 더 유연하게 컨트롤 가능하지만, 개발 및 유지보수 비용 증가

2. 높이 조정 로직의 안정성
    - 현재 방식이 완벽하지 않음 → 더 안정적인 방법 필요
    - 다른 라이브러리 찾아보기


## 마무리 

현재 구현된 방식은 기본적인 동작을 수행하지만 완벽하지 않기에 추가적인 개선이 필요합니다. 

바텀 시트를 직접 구현하는 것이 더 나을지, 라이브러리를 계속 활용하면서 최적화할지를 고민 중입니다. 앞으로도 지속적으로 테스트하고 최적의 해결책을 찾아볼 계획입니다.


<br/>
<br/>
<br/>

## 그리고... 엎었다. 다시.
사실, 이 방식으로 쭉 가보려고 했습니다. 하지만...

바텀 시트는 MVP 기능에서 매우 중요한 역할을 담당하고 있었고 자잘한 오류들을 안고 가기엔 리스크가 너무 컸습니다.

테스트 도중 바텀 시트를 열고 닫거나, 버튼 비활성화 여부를 제어하는 데 잦은 오류가 발생했고 이런 경험은 사용자에게도 피로감으로 이어질 수 있다고 생각했습니다.

그래서 한 주 더 투자하기로 결정했습니다.

결국은... 바텀 시트를 직접 구현하기로 했습니다!..


## 직접 구현한 결과
결론은 성공이였습니다.

바텀 시트와의 싸움 끝에 직접 만든 애니메이션 기반 바텀 시트는 정말 만족스러웠습니다.
"진작 이렇게 할걸..."이라는 생각과 동시에 그간의 삽질이 있었기에 지금의 결과물이 더 소중하게 느껴졌습니다.

### 깨달음 1. 탭을 내가 직접 제어할 수 있었다.
라이브러리 사용할 땐 "탭을 가리기" 위해 사투를 벌였는데, 직접 개발하니까 탭은 그냥 내가 원하는 대로 제어 가능하더군요.
문제 1번은 사실 문제가 아니었습니다.

사실 라이브러리 사용하고도 탭 제어가 가능합니다. 하지만 그 당시엔 바텀시트 라이브러리에만 집중한 나머지 숲을 보지 못하였습니다.

### 깨달음 2. 바텀 시트 높이 조정
라이브러리의 가장 큰 문제였던 TextInput + 키보드 대응 문제도 해결됐습니다.

이전엔 키보드보다 바텀 시트가 먼저 올라오거나, 이전 데이터를 기억해서 버튼이 잘못 활성화되는 경우가 있었는데

직접 구현하니, 이런 문제들이 말끔히 사라졌습니다.

### 마무리 
이번 경험을 통해 확실히 느꼈습니다. 라이브러리가 항상 정답은 아니라는 것을

빠르게 구현해야 할 땐 좋은 선택지가 될 수 있지만,
핵심 기능이라면 직접 구현하는 게 훨씬 안정적이고 무엇보다도 내가 원하는 대로 제어할 수 있다는 점이 장기적으로 봤을 때 유지보수나 확장성 면에서도 더 유리하다고 생각이 듭니다.

이번 경험을 통해 개발자로서 한층 성장한 느낌이 들었고
앞으로도 라이브러리에만 의존하지 않고 필요할 땐 직접 부딪혀보는 자세를 잊지 않으려 합니다.
차