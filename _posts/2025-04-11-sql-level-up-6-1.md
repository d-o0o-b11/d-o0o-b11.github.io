---
title: 6장 정리 - (19강)
description: 결합
# author: d_o0o_b
categories: [Reading, SQL-Level-Up]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 19강: 결합 알고리즘과 성능
지금까지 결합을 결과 기준으로 분류했다면, 이번에는 SQL 내부에서 결합을 수행할 때 사용되는 알고리즘을 기준으로 결합을 살펴본다.

옵티마이저가 선택할 수 있는 주요 결합 알고리즘은 다음 세 가지이다.

1. Nested Loops
2. Hash
3. Sort Merge

이 중 가장 자주 사용되는 알고리즘은 Nested Loops이며 SQL 결합의 기본이 되는 방식이다. 다음으로 중요한 것이 Hash, 마지막으로 Sort Merge가 있다.

대부분의 DBMS는 이 세 가지를 지원하지만, MySQL처럼 Nested Loops만 지원하는 시스템도 존재한다. 또한 DBMS에 따라 이 알고리즘들의 파생 버전도 존재하므로 자신이 사용하는 DBMS의 동향을 주기적으로 확인하는 것이 중요하다.

### 1. Nested Loops
Nested Loops는 이름 그대로 이중 반복을 기반으로 한 알고리즘이다. SQL에서 결합은 두 테이블 간의 연산이므로, 자연스럽게 중첩 루프 구조가 된다.

#### 작동 방식
단순해 보이지만 가장 기본이 되며 중요한 결합 방식이다. 결합 시 어느 테이블을 **구동 테이블(driving table)**로 선택하느냐가 성능에 큰 영향을 미친다.

표면적으로는 A, B 테이블 중 어떤 것을 구동 테이블로 하든 접근 레코드 수는 R(A) * R(B)로 동일해 보이지만, 실제로는 구동 테이블이 작을수록 성능이 유리하다.

이유는 **이중 루프의 외부 루프(구동 테이블)**와 **내부 루프(대상 테이블)**가 비대칭 구조이기 때문이다.


#### 구동 테이블 선택의 핵심: 인덱스
"작은 테이블을 구동 테이블로 선택하라"는 조언은 내부 테이블에 인덱스가 있을 때 비로소 의미가 생긴다.

내부 테이블의 결합 키 필드에 인덱스가 존재하면, 전체를 순회하지 않고 특정 레코드에 빠르게 접근할 수 있기 때문이다.

결합 키가 유일한 경우: 반복 없이 1:1 매칭 가능 → 성능 최고

결합 키가 비유일한 경우: 인덱스를 통해 여러 레코드를 찾게 되므로 반복은 불가피

따라서 "작은 구동 테이블 + 내부 테이블에 인덱스" 조합은 SQL 튜닝의 핵심이다. 반대로, 테이블 설계 및 인덱스 설정 단계에서 어떤 테이블이 내부 테이블이 될지, 어떤 필드에 인덱스를 둘지 충분히 고려해야 한다.



#### Nested Loops의 단점
- 내부 테이블의 결합 키가 유일하지 않으면 반복이 많아져 성능이 저하된다.
- 결합 키가 같은 값에 대해 수백만 건이 대응될 경우, 루프가 길어지며 지연이 생긴다.
- 검색 매개변수에 따라 성능이 비균등하게 나타날 수 있다.

예시로, 점포-주문 관계를 보면 점포 테이블은 작고 주문 테이블은 크다. 점포 ID로 결합할 경우, 대형 점포에서는 히트되는 주문 레코드 수가 많아져 느려진다.

#### 해결책

1. 큰 테이블을 구동 테이블로 선택하여 성능 비균등을 회피
2. 다음에서 설명할 Hash Join 활용

### 2. Hash

#### 작동 방식
Hash는 먼저 작은 테이블을 전부 읽어 해시 테이블을 생성하고 그 후 큰 테이블을 스캔하면서 해시 키로 결합한다.

작은 테이블을 먼저 해싱하는 이유는 워킹 메모리에 올릴 수 있기 때문이다.

주의할 점은 Hash 방식은 등가(=) 결합에서만 사용 가능하며 내부적으로 메모리를 많이 사용하므로 메모리가 부족하면 TEMP I/O가 발생할 수 있다.


#### Hash가 유리한 상황
- 작은 구동 테이블이 없는 경우
- 내부 테이블에 인덱스가 없거나, 결합 키의 선택률이 높아 반복이 많은 경우
- Nested Loops의 성능이 낮은 상황에서 좋은 대안이 된다



### 3. Sort Merge

#### 작동 방식
두 테이블을 결합 키로 정렬한 뒤 동일한 키를 병합하는 방식이다. 간단히 Merge Join이라고도 부른다.

#### 특징
1. 정렬 비용이 발생하므로 메모리 요구량이 크다

2. 부등호(>, <, <=, >=) 조건도 지원 (Hash는 등가만 가능)

3. 정렬이 생략 가능할 수도 있으나 이는 구현 및 상태에 의존한다

4. 일단 정렬이 완료되면 빠르게 병합 가능


#### 유효한 경우
- 결합 대상이 이미 정렬되어 있는 경우
- 결합 후 출력까지 시간이 오래 걸리지 않는 경우
- 그러나 대부분은 Nested Loops 또는 Hash가 우선이다

<br/>
<br/>

## 20강: 결합이 느릴 때의 접근 방법

### 1. 상황에 따른 최적의 결합 알고리즘

| 이름               | 장점               | 단점          |
| :---------------- | :---------------- | :---------------- |
| Nested Loops | - 작고 인덱스 있는 구동 테이블 시 빠름
- OLTP에 적합
- 비등가 결합도 가능|  - 대규모 결합에 부적합
- 인덱스 없거나 선택률 높으면 느림	|
| Hash | 	- 대규모 결합에 적합 | 	- OLTP 부적합
- 메모리 부족 시 성능 저하
- 등가 결합만 가능 |
| Sort Merge | 		- 비등가 결합 가능
- 대규모에도 적합 | 	- 정렬 비용 큼
- 데이터 미정렬 시 비효율적 |


#### 결합 대상 크기에 따른 정리

1. 소규모- 소규모
    어떤 방식이든 성능 차이 없음

2. 소규모 - 대규모
    Nested Loops + 내부 테이블 인덱스

3. 대규모 - 대규모
    Hash 우선, 정렬된 경우 Sort Merge



### 2. 실행 계획 제어
RDB에서는 옵티마이저가 실행 계획을 자동 결정하지만, 사용자가 힌트 등을 이용해 제어할 수도 있다.

- PostgreSQL
    pg_hint_plan 확장 사용, 서버 매개변수로 전체 제어도 가능

#### 주의점
사용자 제어는 데이터 변화에 민감한 리스크를 내포한다.
카디널리티나 데이터 양이 바뀌면, 과거에는 최적이었던 실행 계획이 현재에는 오히려 병목이 될 수 있다.

따라서 힌트를 사용할 때는 변화 가능성까지 예측하여 신중히 판단해야 한다.


### 3. 실행 계획의 불안정성
옵티마이저에게 맡겨도 시간이 지나면서 계획이 비효율적으로 변할 수 있다.
대표적인 경우는 결합 연산이다.

결합은 선택 가능한 알고리즘이 많기 때문에, 데이터 통계의 변화에 따라 다른 방식으로 전환되며 성능 편차가 발생할 수 있다.

이러한 리스크를 줄이기 위해, 가능하다면 결합을 회피하거나 윈도우 함수 등으로 대체하는 방법을 고민해보는 것이 좋다.