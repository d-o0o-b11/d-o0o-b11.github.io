---
title: 7장 정리 - (21강-완강)
description: 서브쿼리
# author: d_o0o_b
categories: [Reading, SQL-Level-Up]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 21강: 서브쿼리가 일으키는 폐해

### 1. 서브쿼리의 문제점
서브쿼리는 실체적인 데이터를 저장하지 않기 때문에, 접근할 때마다 매번 SELECT 문을 실행해서 데이터를 생성해야 한다. 이로 인해 다음과 같은 문제가 발생한다.


#### 연산 비용 추가
서브쿼리는 호출될 때마다 SELECT 문을 수행하므로 복잡한 쿼리일수록 비용이 커진다.

#### 데이터 I/O 비용 발생
메모리가 부족할 경우 서브쿼리 결과가 디스크에 기록된다. 이 과정에서 TEMP 탈락 현상이 발생하며 저장소 성능에 따라 속도가 저하된다.

#### 최적화를 받을 수 없음
서브쿼리는 인덱스나 제약조건 등 메타정보가 부족하여 옵티마이저가 제대로 최적화를 수행할 수 없다.

> 서브쿼리는 편리하지만 정말 필요한 경우에만 사용해야 한다. 불가피하지 않다면 피하는 것이 좋다.
{: .prompt-tip }

<br/>

## 2. 서브쿼리 의존의 단점

### 코드 복잡도  
서브쿼리는 다층 구조로 인해 가독성이 떨어진다.

### 성능 문제 (4가지 요인)  
1. 메모리 또는 디스크에 임시 공간이 필요하다.  
2. 인덱스나 제약조건이 없어 최적화가 어렵다.  
3. 테이블 간 결합 비용이 발생한다.  
4. 동일 테이블에 대해 두 번의 스캔이 필요하다.

### 상관 서브쿼리는 해결책이 아니다  
상관 서브쿼리도 결국 테이블 접근이 두 번 발생하며 성능상의 이점이 없다.

<br/>

## 3. 성능 개선: 윈도우 함수 사용

### 핵심 아이디어  
서브쿼리를 제거하고 윈도우 함수인 `ROW_NUMBER`를 이용하여 필요한 데이터를 1회 스캔으로 얻는다.

### 장점  
- 쿼리가 단순해진다.  
- 실행 계획이 단순해지고 접근 횟수가 1회로 줄어든다.  
- 가독성과 성능 모두 개선된다.

<br/>

## 4. 장기적 리스크 관리

결합을 사용한 쿼리는 다음과 같은 리스크를 안고 있다.

### 결합 알고리즘의 변동 리스크  
- 옵티마이저가 상황에 따라 Nested Loops, Sort Merge, Hash Join 등을 자동 선택함
- 테이블 크기 변화에 따라 알고리즘이 변동되며 성능 저하 발생 가능

### 환경 요인에 의한 성능 지연  
- 인덱스 유무, 메모리 크기, 매개변수 설정 등 외부 요인이 실행 속도에 영향을 준다.  
- 특히 메모리 부족으로 인한 TEMP 탈락은 성능 저하의 핵심 원인이다.

> 결합을 최소화하고 단순한 쿼리를 사용하는 것이 장기적으로 안정적인 성능 확보에 유리하다.
{: .prompt-tip }

<br/>

## 5. 서브쿼리는 정말 나쁠까?

서브쿼리가 무조건 나쁘다고 할 수는 없다. 문제를 구조화하고 이해하기 쉽게 만들어주는 사고 도구이기도 하다. 다만, 실제 실행 관점에서는 SQL의 비절차적 성격과 충돌할 수 있으므로 **최종 구현에서는 성능을 고려한 재구성이 필요하다.**

- 초안 단계에서는 서브쿼리를 적극 활용하되  
- 최종 단계에서는 단순하고 최적화 가능한 형태로 리팩토링해야 한다.
