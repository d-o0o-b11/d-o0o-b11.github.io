---
title: 로그인이 필수는 아니다.  #JWT 토큰을 사용한 이유
description: 우리는 어떻게 인증해야 하는가?
# author: d_o0o_b
categories: [Dev-Notes, Practice]
tags: [typography]
# pin: true
math: true
mermaid: true
# image:
#   path: /commons/devices-mockup.png
#   lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

## 개요
로그인을 꼭 해야 할까? <br/>
보안이 중요한가? 확장성이 중요한가? 사용자 경험이 중요한가? <br/>
이 질문을 해결하는 과정이 곧 인증(Authentication)입니다.

## 로그인 없이도 사용자를 구분할 수 있다.
로그인이라는 개념을 너무 당연하게 받아들이지만 로그인 없이도 원하는 기능을 구현할 수 있습니다.
로그인 도입 목적은 요청을 '누가' 보냈는지 구분이 필요하기 때문입니다.
이 '누가'를 구분하기 위해서는 단순히 문자 또는 숫자로도 구분할 수 있습니다.

여기서 발생할 수 있는 문제는
1. 오타로 인해 다른 사람으로 인식될 수 있다.
2. 누군가 다른 사람인척할 수 있다.

이 문제들을 해결하기 위해 '누구'가 올바른지 확인을 해야합니다.
즉, 특정한 목록에 존재하는 사용자만 입력할 수 있도록 제한해야 합니다.
그리고 해당 사용자가 본인인지 증명할 방법이 필요합니다.
이를 위해서 일반적으로 ID, PW 쌍을 사용한 인증 방식을 도입합니다.

### 정리
사용자의 이름 같이 단순한 형태가 User Credentials이 될 수도 있습니다.
하지만 이는 보안적으로 취약합니다.
- 누구나 볼 수 있다.
- 악의적으로 조작할 수 있다.

*User Credentials - 이 사용자가 누구인지 증명하는 정보

### 위의 문제를 해결하기 위해
1. 누구나 볼 수 있다.
- HTTPS를 사용해 네트워크 상에서 데이터가 암호화되도록 합니다.

2. 악의적으로 조작할 수 있다.
- Session이나 Token을 사용해 검증된 사용자만 접근할 수 있도록 합니다.

## 로그인은 어떻게 동작할까?
매번 요청을 보낼 때마다 ID, PW를 함께 전송하면 문제가 해결될까?
기술적으로는 가능하지만 번거롭습니다.
매 요청마다 ID, PW를 입력하는 것은 사용자 경험을 저하시킵니다.

이를 개선하기 위해 로그인 개념이 등장합니다. 
인증을 한 번만 수행하면 이후 요청에서는 해당 사용자가 누구인지를 자동으로 식별할 수 있도록 하는 것입니다.
이를 위해 사용자 인증 후 해당 사용자를 대신 식별할 수 있는 임의의 코드를 발급합니다.
임의의 코드는 Token이라고 칭하겠습니다.
이 Token을 이용하면 이후의 요청에서 ID, PW를 직접 보내지 않아도 됩니다.

## Token과 Session은 User Credentials의 다른 형태일 뿐이다!
로그인의 본질은 **User Credentials**를 안전하게 전달하는 것입니다.
가장 단순한 형태는 사용자의 이름이 될 수 있지만 앞서 말한 것처럼 보안적으로 취약합니다.
위험한 User Credentials을 계속 사용하는 것이 아닌 어플리케이션 진입 시 동일하게 해당 사용자임을 인증할 수 있는 다른 형태의 User Credentials로 교환한 뒤 이를 사용하면 상대적으로 위험이 감소될 수 있습니다.
그래서 더 안전한 User Credentials 방식으로 Session과 Token이 있습니다.


> Token과 Session은 User Credentials의 다른 형태일 뿐이다. 로그인 과정은 어떤 방식으로 User Credentials를 안전하게 유지하고 전달할 것인지를 고민하는 과정이다.
{: .prompt-info }


## Auth를 적용하면서 고민했던 점

### 1. JWT 사용하면서 겪었던 문제
처음에는 JWT를 AT + RT 구조로 사용했습니다.
하지만 JWT 자체가 서버에서 상태를 관리하지 않는 구조라 만료된 AT를 강제로 막기가 어려웠습니다.

발생할 수 있는 문제들
- 로그아웃해도 AT가 만료될 때까지 유효
- 사용자가 탈퇴해도 기존 JWT를 들고 있으면 여전히 API 요청이 가능

해결 방법
- RT를 DB에서 관리 → 사용자가 로그아웃하면 RT 삭제
- AT 블랙리스트 도입 → 강제로 만료시켜야 할 경우 블랙리스트에 등록

→ 더 이상 만료된 AT가 API 요청에 사용될 수 없도록 개선했습니다! 😀

### 2. RT를 어떻게 관리할까
JWT를 사용할 때 RT를 어떻게 관리할 것인가도 큰 고민이였습니다.
RT 브라우저 로컬스토리지에 저장하면 보안 이슈가 생길 위험이 있고 DB에 저장하면 추가적인 I/O 비용이 발생합니다.

해결 방법
- RT는 DB에 저장 (보안 강화를 위해)
- HttpOnly 쿠키에 저장하여 클라이언트에서 접근 불가능하도록 처리

→ 보안성과 편의성을 모두 잡을 수 있었습니다! 🤩



## 결론
로그인은 필수적인 개념이 아니라 사용자 인증을 간편하고 안전하게 하기 위해 도입된 방법일 뿐입니다.
본질적으로 로그인이란 '내가 누구인지 증명하는 과정'이며 이 과저을 최적화하기 위해 User Credentials의 형태를 바꾸어 가는 과정입니다.

우리는 단순히 세션과 토큰 중 하나를 선택하는 것이 아니라 우리 서비스에 맞는 인증 방식이 무엇인지 고민해야 합니다.

- 보안이 중요한가?
- 확장성이 중요한가?
- 사용자 경험을 최적화할 수 있는가?

> 최적의 선택은 <br/>
> JWT + HttpOnly Cookie + RT + 짧은 AT 만료 시간, <br/>
> Session을 사용한다면 Redis 같은 저장소와 함께 운영
{: .prompt-tip }

<br/>
<br/>


## 추가 설명

### Session 기반 인증
> 서버에서 발급하는 User Credentials

장점
- 서버에서 세션을 관리하기 때문에 보안성이 상대적으로 높다.
- 세션 정보를 변경하면 즉시 반영할 수 있어 유효성을 조정하기 쉽다.

단점

- 서버에서 세션을 저장해야 하므로 확장성이 낮다.
- 여러 서버에서 세션을 공유하려면 별도의 세션 스토리지(Redis 등)가 필요하다.


### Token 기반 인증(JWT)
> 클라이언트가 보관하는 User Credentials

장점

- 서버에 상태 정보를 저장할 필요 없이 stateless하게 인증 가능 → 확장성이 좋다.
- JWT 안에 필요한 정보(사용자 ID, 권한 등)를 담아 한 번 발급하면 별도의 서버 조회 없이 검증 가능하다.

단점

- 토큰이 한 번 발급되면 변조가 어렵다 → 강제 만료시키려면 추가적인 블랙리스트 관리가 필요하다.
- 토큰 크기가 커질수록 네트워크 부담이 증가할 수 있다.