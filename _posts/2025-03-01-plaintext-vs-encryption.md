---
title: Plaintext vs Encryption
description: 데이터는 소중히
categories: [Dev-Notes, Theory]
tags: [typography]
math: true
mermaid: true
---

## 평문(Plaintext)
평문은 암호화되지 않은 원래의 데이터입니다. 데이터가 그대로 노출되어 있어 누구나 쉽게 읽을 수 있습니다.
- 이메일, 비밀번호, 카드 정보 등이 평문으로 전송되면 그 정보는 악의적인 공격자에게 쉽게 노출될 수 있습니다.

## 암호화(Encryption)
암호화는 데이터를 읽을 수 없는 형태로 변환하는 과정을 말합니다. 암호화된 데이터는 키를 가진 사람만 해독할 수 있기 때문에 보안에 유리합니다.
- 암호화된 데이터는 아무리 누군가가 데이터를 가로챈다고 해도 암호화 키 없이는 원래 내용을 알 수 없습니다.

<br/>
<br/>

## 암호화 방식
![Image](https://github.com/user-attachments/assets/7607e624-d0b1-4650-8eb6-df81a7da8c72?raw=true)


### 대칭키 암호화(Symmetric encryption)
- **하나의 키**로 데이터를 암호화하고 복호화합니다. 
- 속도가 빠르지만 키가 유출될 경우 보안이 취약해질 수 있으므로 안전한 키 관리가 필수적입니다.
<br/>

### 비대칭키 암호화(Asymmetric encryption)
- **서로 다른 두 개의 키(공개키와 개인키)**를 사용하여 암호화와 복호화를 수행합니다. 
- 공개키로 암호화한 데이터는 오직 개인키로만 복호화할 수 있습니다.
- 보안성이 뛰어나지만 대칭키 암호화에 비해 속도가 느린 단점이 있습니다.
<br/>

### 해시(Hashing)
- 암호화와는 다르게 데이터를 고정된 길이의 고유한 값으로 변환하는 과정입니다.
- 주로 패스워드 저장 등에 사용되며 일방향 암호화로 복호화가 불가능합니다.



<br/>
<br/>


## 암호화 종류

### 분류
![Image](https://github.com/user-attachments/assets/c54264b1-8a3a-49ba-bc6c-d4168b641f57?raw=true){: w='400' }


#### 양방향 암호화 (Reversible Encryption)
암호화된 데이터를 원래 상태로 복원할 수 있는 방식입니다. 암호화(Encryption)와 복호화(Decryption)가 모두 가능하다는 특징을 가집니다.

주로 **기밀성**을 보장하는 데 사용됩니다.
- 기밀성 (Confidentiality) 
    - 데이터를 권한이 있는 사용자만 읽을 수 있도록 보호
    - 데이터를 암호화하여 전송하고 올바른 복호화 키를 가진 사용자만 원본 데이터 복원 가능


#### 단방향 암호화 (Hashing)
한 번 암호화된 데이터는 원래 상태로 복원할 수 없는 방식입니다.

복호화가 불가능하며 주로 **무결성**을 보장하는 데 사용됩니다.
- 무결성 (Integrity)
    - 데이터가 전송/저장되는 동안 변경되지 않았음을 보장
    - 해시 함수는 데이터를 변환하여 고정된 크기의 해시값을 생성하고 동일한 입력값은 항상 동일한 해시값 생성


<br/>
<br/>


## 양방향 알고리즘
크게 2가지로 나뉩니다.

![Image](https://github.com/user-attachments/assets/a1aff6eb-2157-4c15-b395-258537f1ad3d?raw=true){: w='400' }

<br/>


### 1. 대칭키 암호화 (Symmetric Key Encryption)

![Image](https://github.com/user-attachments/assets/c932d544-92c2-4834-acd7-96006da2b23b?raw=true)
>암호화와 복호화에 동일한 키를 사용하는 방식입니다.

<br/>

#### 장점
1. 빠른 속도
- 동일한 키를 사용하기 때문에 비대칭키 암호화보다 연산 속도가 빠릅니다.

2. 구현이 비교적 간단
- 하나의 키만 사용하므로 구현이 단순하고 코드 및 프로세스가 간결합니다.

3. 암호문의 크기가 원본 데이터 크기와 비슷
- 비대칭 암호화 방식과 달리, 암호화 후 데이터 크기 증가가 적습니다.

<br/>

##### 단점
1. 키 분배(키 교환)문제
- 송수신자가 같은 키를 공유해야 하므로 안전하게 키를 전달하는 것이 어렵습니다.
- 네트워크에서 키가 탈취되면 암호화된 데이터도 쉽게 복호화될 위험이 있습니다.

2. 낮은 확장성
- 다수의 사용자와 보안 통신하려면 각 사용자와 개별적인 키를 생성해야 합니다.
- 사용자 수가 많아질수록 키 개수가 기하급수적으로 증가하여 관리가 어려워집니다.

3. 상대적으로 낮은 보안성
- 키가 유출되면 암/복호화가 모두 가능하여 심각한 보안 사고로 이어질 수 있습니다.

<br/>

> 대칭키 암호화는 **기밀성**을 보장하는 데 사용됩니다.
{: .prompt-info }



### 2. 비대칭키 암호화 (Asymmetric key)

![Image](https://github.com/user-attachments/assets/8041238d-250c-485e-91f0-b55095686cf3?raw=true)
>암호화와 복호화에 서로 다른 키를 사용하는 방식입니다.  <br/>
>일반적으로 **공개키(Public Key)**와 **개인키(Private Key)**를 사용하여 데이터를 암호화하고 복호화합니다.

<br/>


#### 장점
1. 키 분배 문제 해결
- 공개키는 누구에게나 공유 가능하며 키 교환이 용이합니다.
- 키가 네트워크에서 노출되더라도 개인키 없이는 복호화가 불가능하므로 보안성이 높습니다.

2. 높은 확장성
- 각 사용자당 공개키/개인키 한 쌍만 관리하면 되므로 효율적으로 통신할 수 있습니다.
- SSL/TLS 같은 인터넷 보안 프로토콜에서 활용되어 안전한 인증 방식으로 활용됩니다.

3. 전자서명 지원
- 개인키로 서명한 데이터를 공개키로 검증할 수 있어 무결성을 보장할 수 있습니다.

<br/>

#### 단점
1. 느린 속도
- 대칭키 암호화보다 연산량이 많아 속도가 느립니다.
- 대량의 데이터 암호화에는 부적합하므로 실무에서는 보통 대칭키 암호화와 조합하여 사용합니다.

2. 공개키 위/변조 위험
- 공개키가 위/변조될 경우 악성 공개키를 이용한 공격이 가능해집니다.
- 신뢰할 수 있는 기관(CA, Certificate Authority)이 공개키를 인증하는 PKI(Public Key Infrastructure) 가 필요합니다.

3. 암호화 후 데이터 크기 증가
- 암호화 후 데이터 크기가 커지는 문제가 있습니다.
- RSA 같은 알고리즘은 짧은 데이터 블록만 암호화할 수 있으며 실무에서는 보통 세션 키(대칭키)를 암호화하는 용도로만 사용됩니다.

<br/>

> 비대칭키 알고리즘은 **기밀성** 기능을 제공합니다.
{: .prompt-info }

<br/>
<br/>

## 단방향 암호화

![Image](https://github.com/user-attachments/assets/4da8a691-e900-4cec-8b91-bbbae0067096?raw=true){: w='400' }
>단방향 암호화는 데이터를 한 번 변환하면 다시 복원할 수 없는 방식입니다.

<br/>

### 특징
- 데이터를 암호화한 후 복호화가 불가능한 방식입니다.
- 같은 입력값은 **항상 동일한 출력값(해시값)**을 생성합니다.
- 주로 비밀번호 저장이나 데이터 무결성 검증 용도로 사용됩니다.

### 대표적인 단방향 알고리즘: 해시 함수
![Image](https://github.com/user-attachments/assets/49a26c75-9142-4e9b-ab55-a73e278ccfbf?raw=true)

- 해시 함수는 입력값을 고정된 길이의 해시값으로 변환합니다.
- 한 번 변환된 값은 복원할 수 없으며 원본 데이터를 추론하는 것도 불가능합니다.

<br/>

> 단방향 알고리즘은 **무결성**을 보장하는 데 사용됩니다.
{: .prompt-info }

<br/>
<br/>


<!-- ## 추가 
> 실무에서는 대칭키와 비대칭키를 조합하여 사용합니다.
{: .prompt-tip } -->