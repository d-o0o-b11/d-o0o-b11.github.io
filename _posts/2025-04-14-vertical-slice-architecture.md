---
title: 수직적 구조 (Vertical Slice Architecture)
description: 요청 단위로 코드를 슬라이스처럼 분리하여 응집도와 유지보수성을 높이는 아키텍처 스타일
# author: d_o0o_b
categories: [Dev-Notes, Practice]
tags: [typography]
# pin: true
math: true
mermaid: true
---


## 개요

수직적 구조(Vertical Slice Architecture)는 **기능 단위로 코드를 수직 분리**하여 구성하는 아키텍처입니다.  
전통적인 계층형 구조(`Controller → Service → Repository`)와 달리 **하나의 요청을 처리하는 모든 로직을 한 슬라이스(slice)** 로 묶어 모듈화합니다.

이 아키텍처는 **응집력 높은 코드 구성**, **변경에 강한 구조**, **테스트 용이성**을 강조하며 **CQRS(Command/Query Responsibility Segregation)**나 기능 단위로 책임을 명확히 분리하고자 하는 프로젝트에서 유용합니다.

<br/>

## 구조
<!-- 요청 하나를 처리하는 코드 묶음을 "슬라이스(slice)"처럼 세로로 묶자! — 이게 수직적 구조의 핵심입니다. -->

```text
post/
  ├── CreatePost/
  │   ├── CreatePostController
  │   ├── CreatePostService
  │   └── CreatePostRepository
  └── GetPost/
      ├── GetPostController
      ├── GetPostService
      └── GetPostRepository

```

### 특징

- 하나의 슬라이스는 **기능 단위 요청을 처리하는 독립된 유닛**입니다.
- 각 슬라이스는 자체적으로 입력 → 처리 → 응답 흐름을 갖습니다.
- 다른 기능과 거의 의존하지 않으며 **모듈처럼** 작동합니다.

<br/>

## 장점
- 기능 단위로 코드가 응집되어 유지보수성이 높습니다.
- 테스트 및 리팩토링이 용이합니다.
- 기능 단위 책임이 분명해 온보딩할 때 전체 흐름을 이해하기 쉽습니다.
- 점진적으로 마이크로서비스로 전환하기 용이합니다.

<br/>

## 단점
- 팀에 익숙하지 않으면 진입 장벽이 생길 수 있습니다.
- 슬라이스가 많아질수록 디렉토리 구조가 깊어질 수 있습니다.
- 공통 로직의 재사용을 위해 별도 설계가 필요합니다 (ex. util, 도메인 서비스 등).

<br/>

## 클린/헥사고날 아키텍처와의 차이점

| 항목    | 수직적 구조                           | 클린 아키텍처 / 헥사고날 아키텍처    |
| ----- | -------------------------------- | ---------------------- |
| 중심 개념 | 기능 단위 수직 슬라이스                    | 계층 간 책임 분리 및 의존성 방향 설정 |
| 설계 방향 | 요청/기능 중심의 모듈화                    | 도메인 중심의 계층 구조 설계       |
| 공존 여부 | 함께 사용 가능 <small>(ex. 슬라이스 내부에서 클린 구조 적용)</small> | 함께 사용 가능               |

> 슬라이스 안에서도 클린/헥사고날 구조를 적용하여 탄탄하게 만들 수 있습니다.
{: .prompt-tip }

<br/>

## 마무리
수직적 구조는 "기능 중심"의 사고를 유도합니다.   
하나의 요청이 어떻게 들어와 처리되고 어떤 결과를 내보내는지 코드 흐름이 명확하게 보입니다.

### 수직적 구조가 적합한 상황
- CQRS(Command/Query 분리) 구조를 사용할 떄
- 기능별 유지보수가 많은 서비스
- 팀원이 많고 기능별 작업을 분리하고 싶을 때
- 점점 커지는 모놀리스를 기능 단위 마이크로서비스로 분리하고 싶을 때


<!-- ## 적용 후기
제가 헥사고날 아키텍처를 처음 도입했을 때는 "웹 컨트롤러 말고 다른 진입점이 필요할까?"라는 생각이 들었습니다.
하지만 CLI나 메시지 큐(Kafka, RabbitMQ)를 다루면서, 한 유스케이스에 다양한 진입점을 연결할 수 있다는 점에서 큰 이점을 느꼈습니다.

특히 아래와 같은 경우에 헥사고날 아키텍처는 탁월합니다.
- 다양한 외부 채널에서 동일한 비즈니스 로직을 실행해야 할 때
- 웹, 배치, 메시지 큐 등 다채로운 I/O 환경이 존재할 때
- 시스템 경계를 명확히 하고 싶을 때

<br/>

## 마무리

헥사고날 아키텍처는 매우 실용적인 구조입니다.
과하지 않으면서도, 도메인과 기술을 잘 분리할 수 있도록 도와줍니다.

물론 모든 상황에 적합한 구조는 아닙니다.
그래서 저는 아래 질문을 스스로에게 던지며 이 구조의 도입을 결정합니다.

- 다양한 입출력 채널이 존재하는가?
- 도메인 로직을 프레임워크나 I/O로부터 분리할 필요가 있는가?
- 기술 변화에 유연하게 대처할 필요가 있는가?

이 질문에 "YES"가 많다면 헥사고날 아키텍처는 좋은 선택이 될 수 있습니다. -->