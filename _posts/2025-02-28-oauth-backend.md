---
title: OAuth 적용 (kakao, google)
description: OAuth 적용 (w. RT를 곁들인)
categories: [Dev-Notes, Practice]
tags: [typography]
math: true
mermaid: true
---

## 개요
사이드 프로젝트를 진행하면서 기획자분들이 카카오 소셜 로그인 기능을 원하셨습니다. 이를 보다 효율적으로 활용하기 위해, 카카오 로그인 보일러플레이트를 만들어 사용해 왔습니다.

그동안 기존 보일러플레이트가 최선이라 생각했지만, 이번 앱 개발에서 프론트엔드와 백엔드를 모두 맡게 되면서 전체적인 흐름을 다시 정리할 필요성을 느꼈습니다. 자연스럽게 기존 구조를 돌아보게 되었고, 더 효율적인 방식이 있을 것 같아 보일러플레이트를 수정하기로 결심했습니다.

<br/>
<br/>

## 일반적인 OAuth 구조
<!-- ![Image](https://github.com/user-attachments/assets/ff1aa562-47ad-433d-adbd-2e709391f1a9?raw=true) -->
![Image](https://github.com/user-attachments/assets/2e9ccb9f-cd7e-46a6-b593-43f093abc811?raw=true)

<br/>


## 내가 추구했던 OAuth 구조
![Image](https://github.com/user-attachments/assets/dd07be5e-d3ac-43e4-8b49-b2191889c382?raw=true)

<br/>

### 서버에서 처리하는 이유
**보안적인 측면**에 대해 고려하였습니다. 브라우저 환경에서 API 키나 클라이언트 시크릿 같은 중요한 정보가 노출될 위험이 있기 때문에, 서버에서 이를 관리하는 것이 보다 안전하다고 판단했습니다.  
이 방식은 이후 다른 OAuth Provider Service(Google, Facebook 등)와의 확장에도 용이한 구조였습니다.

  
.  
.  
.  
  


(작성하고 보니... 🤔)
저는 백엔드 서버를 프록시 서버처럼 사용하고 있었습니다.
클라이언트가 카카오 API에 직접 요청하는 것이 아니라, 백엔드가 중간에서 요청을 받아 대신 처리하는 방식이었죠.

사실, 프록시 서버는 보안, 트래픽 관리, 캐싱 등의 이유로 사용되지만, 제 경우에는 꼭 필요하지 않음에도 백엔드를 하나 더 둔 것 같은 느낌이 들었습니다. 😂
그럼에도 불구하고 API 키 보호 및 확장성을 고려했을 때 나쁘지 않은 선택이었다고 생각합니다.


<br/>

### 앱 개발 과정에서 겪은 문제
처음에는 SDK를 활용한 인앱 로그인 방식을 고려했습니다. 그러나 이를 구현하려면 환경 변수를 프론트엔드에서 관리해야 했고, 서버에서 idToken을 검증하는 방식으로 동작해야 했습니다.

하지만 앱 개발이 처음이었던 저에게 인앱 로그인 방식은 러닝 커브가 높았고 출시 일정이 정해져 있어 빠르게 해결책을 마련해야 했습니다. 결국, 기존 보일러플레이트 구조를 그대로 활용할 수 있는 웹뷰 로그인 방식으로 전환했습니다.

이 과정에서 **Refresh Token(RT) 관리 방식**에 집중했습니다.
개발하다 보면 보안적인 부분을 놓칠 수 있기 때문에 이를 간과하지 않도록 더욱 신경을 기울였습니다.
RT를 클라이언트에 반환하는 방식이 보안적으로 충분히 안전한지 고민하며 보다 안전한 관리 방안을 모색하는 데 집중했습니다.


<br/>

## Refresh Token(RT) 반환이 필요한가?
이전 구조에서는 Access Token(AT)과 Refresh Token(RT)을 함께 반환하는 방식을 사용했습니다.
AT가 만료되면 RT를 이용해 새로운 AT를 발급받아야 했고, 많은 개발자들이 이를 일반적인 방식으로 사용했기 때문에 저도 자연스럽게 같은 방식을 따랐습니다.

하지만 AT는 탈취될 위험이 있기 때문에 만료 시간을 짧게 설정하고, RT는 만료 시간을 길게 주어 반환하는 방식이었습니다.
이 과정에서 이질감을 느끼기 시작했습니다. RT를 클라이언트에 반환하면, RT 자체도 탈취될 가능성이 있다는 점에서 보안적으로 정말 해결된 것인가 하는 의문이 들었기 때문입니다.

현재는 RT를 클라이언트에 반환하지 않고 서버에서 직접 관리하는 방식을 고려하고 있습니다.


<br/>

### 왜 RT를 서버에서 관리하는가?
AT의 만료 시간을 짧게 설정하는 이유는 보안 문제, 즉 토큰 탈취 가능성 때문입니다.
그렇다면 RT도 탈취될 가능성이 있으며, 이는 더 큰 보안 위협이 될 수 있습니다.

- RT
<br/>
    AT보다 유효 기간이 길기 때문에 탈취될 경우 장기간 악용될 위험이 있습니다.
- AT
<br/>
    유출되면 짧은 시간 내에 대응할 수 있지만, RT가 유출되면 더 큰 피해를 초래할 수 있습니다.

이러한 점들을 고려했을 때, RT를 서버에서 안전하게 관리하는 방식이 보안 측면에서 더 적절한 선택이라고 판단했습니다.




<br/>
<br/>

## AT만 반환하는 구조
![Image](https://github.com/user-attachments/assets/6193b605-a8f6-4e88-9155-195b414b1e35?raw=true)


<br/>
<br/>

## 회고
OAuth를 적용하면서, 보일러플레이트도 지속적으로 업데이트하고 개선해나가야 한다는 점을 깨달았습니다.
시간이 지나면서 개발 환경이나 요구사항이 변하고, 그에 맞춰 더 나은 해결책을 찾을 수 있기 때문입니다.

이번 리팩토링 과정에서는 **보안성 강화**를 위해 **Refresh Token(RT)을 클라이언트에 반환하지 않고** 서버에서 직접 관리하는 방식을 도입했습니다.
이 방식이 절대적인 정답은 아닐 수 있지만, 보안적인 측면에서는 더 안전한 선택이라고 판단했습니다.

개발에는 하나의 정답이 존재하는 것이 아니라, 상황에 따라 최선의 선택을 계속해서 고민해야 한다는 점을 다시 한 번 깨닫는 시간이었습니다.

