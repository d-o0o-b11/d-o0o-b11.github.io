---
title: 부하 테스트
description: 내 쿼리가 최적화되었을까?
# author: d_o0o_b
categories: [Minime]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 개요

최종 목표에 연결된 **카테고리 하위 목록을 조회하는 API**

이 API는 유저가 홈 화면에 진입 시 항상 호출되며 내부적으로는 **카테고리 정보 + 해당 날짜에 생성된 todo 목록**까지 불러와야 하는 꽤 복합적인 기능을 포함하고 있습니다.

특히 "초기 진입 성능 = 유저 첫인상"으로 직결되기 때문에 **실제 운영 환경을 가정한 부하 테스트**를 통해 로직을 선택하기로 했습니다.


<br/>

## 문제 정의

```ts
// 방법 1: Prisma include를 사용하는 JOIN 방식
category.findMany({
  where: { ... },
  include: {
    todoList: {
      where: {
        createdAt: {
          gte: todayStart,
          lte: todayEnd,
        },
      },
    },
  },
});

```

위와 같은 Prisma의 include 방식은 관계형 데이터를 JOIN 한 번에 가져올 수 있는 장점이 있습니다.
하지만 내부적으로 `LEFT JOIN + WHERE`를 수행하기 때문에 결과셋이 클 경우 성능 저하 가능성이 존재합니다.

<br/>

그래서 고민했던 대안은 아래 코드입니다.

```
// 방법 2: for-await-of 루프를 통한 개별 todo 쿼리
const categoryList = await category.findMany(...);

for await (const category of categoryList) {
  const todos = await todo.findMany({
    where: {
      categoryId: category.id,
      createdAt: {
        gte: todayStart,
        lte: todayEnd,
      },
    },
  });
  ...
}

```

이 방식은 카테고리만 먼저 가져오고 todo는 필요한 경우에만 개별적으로 조회합니다.
`JOIN`을 피할 수 있지만 카테고리 수만큼 DB 쿼리가 추가로 발생하게 됩니다. (= N+1 문제)

<br/>

## 전제 조건
- 한 유저가 가질 수 있는 카테고리 최대 수는 8개
- 오늘 날짜에 생성된 todo만 필터링
- 응답은 로그인한 사용자 기준으로 제공 (JWT 필요)

즉, 최대 1명의 유저가 API 한 번 요청할 때 <br/>
→ include 방식은 쿼리 1번 <br/>
→ for-await 방식은 최대 9번의 카테고리 조회 + todo 갯수 번 쿼리가 날아가는 구조 <br/>

실제 EC2 환경과 비슷하게 맞춘 로컬 컨테이너에서 부하 테스트를 돌려보겠습니다.

<br/>

## 테스트 구성

### 환경 세팅
EC2 t2.micro 기준 (1 vCPU / 1GB RAM)

동일한 리소스 제한을 Docker 컨테이너에 설정 <br/>
(cpus: "0.5", memory: 1GB)

### 사용한 라이브러리
Artillery

### 시나리오
- 총 테스트 시간: 60초
- 초당 요청 수 (RPS): 10 requests/sec
- 예상 응답 상태코드: 200 OK
- 인증 필요: O (JWT 토큰 사용)
    - 10명의 유저 토큰을 무작위로 사용


### 테스트 결과 비교

| 항목   | `include` 사용 | `for-await` 사용|
| :--------------------------- |:---------------------------|:---------------------------|
| 요청 수	  | 600 | 600 |
| 평균 응답시간	 | 🟢 6.6ms| 🔴 152.6ms |
| 응답시간 p95	  | 🟢 12.1ms | 🔴 982.6ms |
| 응답시간 p99  | 🟢 68.7ms | 🔴 2515.5ms |
| 총 다운로드 바이트  | 🟢 322.8 KB | 🔴 1.1 MB |
| 초당 요청 처리 | 🔴 5/sec | 🟢 10/sec  |

> 모든 요청이 정상 응답(HTTP 200)으로 처리되었고 실패는 없었습니다.

### 분석
- `for-await` 방식은 구조상 쿼리 수가 많아져서 평균 응답속도가 23배 이상 느렸습니다.
- 응답 시간 `p99` 기준 2.5초가 넘는 요청도 발생했는데 이는 실사용자 입장에서 완전히 체감 가능한 지연입니다.
- 다운로드된 응답 데이터 크기도 3배 이상 차이 났습니다. → 불필요한 데이터 or 반복 조회가 있었던 것으로 추정
- include 방식은 DB 단에서 `JOIN + 필터링`을 한 번에 수행함으로써 최소 쿼리 횟수, 최적 응답속도를 확보할 수 있습니다.

<br/>

## 결론: 왜 `include` 방식을 선택했는가

이 프로젝트에서는 한 명의 유저가 가질 수 있는 카테고리는 최대 8개로 제한되어 있으며
각 카테고리에 연결된 todo는 하루 단위로 필터링되는 구조입니다.
실제로 한 번의 쿼리로 처리할 수 있는 데이터 범위는 충분히 제한적이고
성능 저하를 일으킬만한 수준의 대량 조인은 아닙니다.

`for-await` 방식을 고민한 이유는 
> "카테고리에 오늘 생성된 todo가 아예 없을 수도 있는데, 그럼 조인 성능 안 좋아지는 거 아닌가?"

라는 생각이 들었기 때문입니다.

하지만 실제로 Prisma에서 `include + where`를 사용할 경우, LEFT OUTER JOIN으로 처리됩니다.

즉, 해당 카테고리에 todo가 없으면 null이 아니라 빈 배열([])로 반환되며
불필요한 I/O나 null 처리 이슈 없이 깔끔하게 대응됩니다.

반면 `for-await` 방식은 매 카테고리마다 개별 쿼리를 날리게 되므로 todo가 있든 없든 불필요한 요청이 반복되고
이는 부하 테스트 결과에서도 응답 시간의 큰 차이로 이어졌습니다.

## 마무리
이번 부하 테스트는 단순히 속도 수치를 비교하는 것을 넘어서
실제 운영 환경에서 어떤 구조가 더 일관된 퍼포먼스를 보장하는가에 대한 실험이었습니다.

약간의 테스트 코드 작성, 도커 환경 튜닝, 그리고 수치 해석 등 많은 시간이 들었지만
덕분에 “왜 이렇게 구현했는가?”라는 질문에 명확하게 답할 수 있게 되었습니다.

성능은 단순한 속도 싸움이 아니라, 사용자 경험을 위한 배려라고 생각합니다.

