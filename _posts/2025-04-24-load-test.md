---
title: 부하 테스트
description: 내 쿼리가 최적화되었을까?
# author: d_o0o_b
categories: [Minime]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 개요
사용자 홈 진입 시 호출되는 **카테고리 하위 목록 조회 API**는 내부적으로 다음을 포함합니다.

- 유저별 카테고리 목록
- 각 카테고리에 연결된 오늘 날짜의 todo 리스트

이 API는 **첫 진입 속도 = 사용자 첫인상**과 직결되므로 실제 운영 환경과 유사한 조건에서의 성능 검증이 필요했습니다.

<br/>

## 문제 정의
### 방법 1: include 기반 JOIN 방식 (단일 쿼리)
```ts
category.findMany({
  where: { ... },
  include: {
    todoList: {
      where: {
        createdAt: {
          gte: todayStart,
          lte: todayEnd,
        },
      },
    },
  },
});

```

위와 같은 Prisma의 include 방식은 관계형 데이터를 JOIN 한 번에 가져올 수 있는 장점이 있습니다.
하지만 내부적으로 `LEFT JOIN + WHERE`구조로 인해 결과셋이 클 경우 성능 저하 가능성이 존재합니다.

---

### 방법 2: for-await-of 기반 N+1 쿼리

```ts
const categoryList = await category.findMany(...);

for await (const category of categoryList) {
  const todos = await todo.findMany({
    where: {
      categoryId: category.id,
      createdAt: {
        gte: todayStart,
        lte: todayEnd,
      },
    },
  });
  ...
}

```

이 방식은 카테고리만 먼저 가져오고 todo는 필요한 경우에만 개별적으로 조회합니다.
`JOIN`을 피할 순 있지만 카테고리 수만큼 DB 쿼리가 추가로 발생하게 됩니다. (= N+1 문제)

<br/>

## 테스트 조건

| 항목            | 값                                               |
| ------------- | ----------------------------------------------- |
| 유저당 최대 카테고리 수 | 8개                                          |
| todo 조회 조건    | 오늘 생성된 항목만                                  |
| 인증 방식         | JWT <small>(10명 사용자 토큰 무작위 사용)</small>     |
| 테스트 도구        | Artillery                                       |
| 환경            | Docker (0.5 vCPU, 1GB RAM) ← EC2 t2.micro 유사 스펙 |
| 시나리오          | 60초간 RPS 10 유지 (총 요청 600건)                      |


<br/>

## 테스트 결과 비교

| 항목   | `include` 사용 | `for-await` 사용|
| :--------------------------- |:---------------------------|:---------------------------|
| 요청 수	  | 600 | 600 |
| 평균 응답시간	 | 🟢 6.6ms| 🔴 152.6ms |
| 응답시간 p95	  | 🟢 12.1ms | 🔴 982.6ms |
| 응답시간 p99  | 🟢 68.7ms | 🔴 2515.5ms |
| 총 다운로드 바이트  | 🟢 322.8 KB | 🔴 1.1 MB |
| 초당 요청 처리 | 🔴 5/sec | 🟢 10/sec  |

> 모든 요청이 정상 응답(HTTP 200)으로 처리되었고 실패는 없었습니다.

### 분석
- `for-await` 방식은 구조상 쿼리 수가 많아져서 평균 응답속도가 23배 이상 느렸습니다.
- 응답 시간 `p99` 기준 2.5초가 넘는 요청도 발생했는데 이는 실사용자 입장에서 체감 가능한 지연입니다.
- 다운로드된 응답 데이터 크기도 3배 이상 차이 났습니다. → 불필요한 데이터 or 반복 조회가 있었던 것으로 추정됩니다.
- `include` 방식은 DB 단에서 `JOIN + 필터링`을 한 번에 수행함으로써 최소 쿼리 횟수, 최적 응답속도를 확보할 수 있습니다.

<br/>

## 결론: 왜 `include` 방식을 선택했는가

이 프로젝트에서는 한 명의 유저가 가질 수 있는 카테고리 수는 최대 8개로 제한되어 있습니다.   
각 카테고리에 연결된 todo는 하루 단위로 필터링되는 구조이며 결과 데이터의 양 자체는 비교적 작고 예측 가능한 범위입니다.

`for-await` 방식을 고려한 이유는 
> "특정 카테고리에 todo가 아예 없을 수도 있으므로 필요한 경우에만 쿼리를 날리는 구조가 불필요한 데이터 로드를 방지할 수 있다고 판단했기 때문입니다."

---

하지만 실제 테스트 결과는 이러한 가설과는 다르게 나왔습니다.

Prisma의 `include + where` 방식은 내부적으로 **LEFT OUTER JOIN**으로 처리되며 todo가 없는 카테고리는 null이 아닌 **빈 배열([])**로 안전하게 반환됩니다.   
필요 없는 데이터가 강제로 로드되거나 null 처리 이슈가 발생하는 일은 없었습니다.

반면, `for-await` 방식은 카테고리마다 개별 쿼리를 수행하므로 todo가 있든 없든 불필요한 DB I/O가 반복적으로 발생합니다.   
이는 부하 테스트 결과에서도 평균 응답 시간과 지연 구간(p95/p99) 모두에서 명확한 성능 저하로 이어졌습니다.

<br/>

## 마무리

데이터베이스 실행 계획만으로는 쿼리의 성능을 충분히 예측할 수 없습니다.

이처럼 자주 호출되고 사용자 체감에 직결되는 API는 단순 이론보다 실제 환경에서의 부하 테스트가 훨씬 신뢰할 수 있는 판단 근거가 됩니다.

이번 실험은 단순히 "속도가 빠른가"를 넘어서 **어떤 구조가 더 안정적이고 일관된 퍼포먼스를 내는가**를 검증한 과정이었습니다.

테스트 환경 셋업, 시나리오 설계, 수치 기반의 해석에 이르기까지 "왜 이 방식으로 구현했는가?"에 명확한 이유와 확신을 갖게 되었습니다.

