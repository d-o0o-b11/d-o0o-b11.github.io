---
title: REST API 원칙
description: REST API의 개요와 설계 원칙
# author: d_o0o_b
categories: [Dev-Notes, Theory]
tags: [typography]
# pin: true
math: true
mermaid: true
---

## 개요

REST(Representational State Transfer) API는 웹 아키텍처 스타일 중 하나로 HTTP를 기반으로 **클라이언트와 서버 간의 리소스 중심 통신**을 가능하게 하는 구조입니다.

초기에는 SOAP(Simple Object Access Protocol), RPC(Remote Procedure Call) 와 같은 복잡한 프로토콜이 사용되었으나 REST는 이들에 비해 **간결하고 유연한 설계**를 제공합니다.  
**HTTP 메소드와 URI를 활용하여 리소스(자원, Resource)을 명확하게 표현**하는 것이 핵심입니다.


<br/>

## REST의 기본 특징

#### 1. 클라이언트-서버 구조
- 클라이언트와 서버는 **역할이 명확히 분리**됩니다.
- 클라이언트는 요청, 서버는 리소스 처리 및 응답만을 담당합니다.

#### 2. 무상태성 (Stateless)
- **서버는 요청 간 상태를 저장하지 않습니다.**
- 모든 요청은 독립적으로 처리되며 필요한 정보는 요청마다 포함되어야 합니다.

#### 3. 리소스 중심 설계
- 모든 데이터는 **리소스** 로 간주되며 **URI(Uniform Resource Identifier)**로 고유하게 식별됩니다.

ex. `/users`는 사용자 목록을 나타내는 리소스입니다.

#### 4. 다양한 표현 (Representation)
- 리소스는 JSON, XML 등 다양한 포맷으로 표현될 수 있으며 일반적으로 JSON을 사용합니다.

#### 5. HTTP 메소드 기반 동작
- GET, POST, PUT, DELETE 등 표준 메소드를 통해 리소스를 조작합니다.

<br/>

## REST API가 등장한 배경
초기 웹 API는 SOAP, XML-RPC 같은 무거운 통신 구조를 사용했습니다.  
이러한 방식은 **복잡한 명세, 낮은 확장성, 높은 학습 비용** 등의 문제를 야기했습니다.

> REST는 HTTP의 구조적 장점을 극대화하여 단순하고 범용적인 웹 통신 방식을 제공합니다.

### SOAP, RPC가 복잡한 이유
1. 엄격한 메시지 포맷
    - XML 기반으로 통신하여 메시지 구조가 길고 복잡합니다. 
    - 클라이언트와 서버 모두 XML을 파싱해야 하므로 성능에 부담을 줍니다.

2. 추가 스펙 요구
    - WSDL, UDDI 등 별도 명세와 보안/트랜잭션 처리 확장이 필요합니다.

3. HTTP의 기능 미활용
    - 모든 요청을 POST로 처리하며 HTTP의 메소드, 캐싱, 상태코드 등을 활용하지 않습니다.

> 이러한 한계를 극복하기 위해 **REST**가 등장했습니다.
{: .prompt-tip }

### HTTP의 장점을 어떻게 살렸을까?

| HTTP 기능      | REST 활용 방식                           | 효과                                |
| ------------ | ------------------------------------ | --------------------------------- |
| HTTP 메서드 | GET, POST, PUT, DELETE 등             | 클라이언트 의도를 명확히 표현합니다. (CRUD에 자연스럽게 매핑) |
| URI      | 리소스 고유 식별자 역할                        | 리소스 중심의 설계가 가능합니다                     |
| 상태 코드    | 200 OK, 201 Created, 404 Not Found 등 | 응답 의미를 명확하게 전달합니다                    |
| 헤더       | Content-Type, Accept 등               | 다양한 데이터 포맷 지원 및 협상이 가능합니다                |
| 캐싱       | ETag, Cache-Control                  | 서버 부하를 줄이고 클라이언트 응답 속도를 향상시킵니다          |

[상태 코드 표 보기](https://developer.mozilla.org/ko/docs/Web/HTTP/Reference/Status)
<!-- REST는 추가적인 명세 없이도 HTTP라는 웹의 기본 인프라 위에서 작동하기 때문에 학습 비용이 낮고 확장성이 높습니다. -->

### REST API의 장점

| 항목       | 설명 |
|------------|------|
| 단순함   | HTTP 기반이며 구현이 쉽고 직관적입니다. |
| 확장성   | 클라이언트-서버 분리를 통해 시스템 변경에 유연하게 대응할 수 있습니다. |
| 호환성   | HTTP 기반이므로 모든 웹 인프라와 호환됩니다. |
| 효율성   | 무상태 구조로 인해 서버 리소스를 최소화할 수 있습니다. |

<br/>

## RESTful API 설계 원칙

### 1. 리소스 기반 URI 설계
모든 리소스는 URI로 표현되며 명사형 구조를 사용합니다.
동사는 사용하지 않으며 복수형을 사용하고 계층 구조를 유지합니다.

```text
GET /users           // 사용자 목록
GET /users/42        // 특정 사용자 조회
POST /posts          // 게시글 생성
PUT /posts/10        // 게시글 전체 수정
DELETE /posts/10     // 게시글 삭제
```

```text
/users/{userId}/orders/{orderId}
```

### 2. HTTP 메소드의 적절한 사용

| 메소드    | 설명       |
| ------ | -------- |
| GET    | 리소스 조회    |
| POST   | 리소스 생성    |
| PUT    | 리소스 전체 수정 |
| PATCH  | 리소스 부분 수정 |
| DELETE | 리소스 삭제    |


### 3. 무상태성 (Stateless)
- 서버는 요청 간의 상태를 유지하지 않습니다.
- 모든 요청은 완전한 정보를 포함해야 합니다.

```text
GET /orders HTTP/1.1  
Authorization: Bearer {token}
```
> 클라이언트는 요청마다 인증 정보를 포함해야 하며 서버는 세션 상태를 저장하지 않습니다.

### 4. 일관된 URI 규칙
- **소문자 + 하이픈(-)** 사용을 권장합니다.

```text
GET /user-profile  (O)  
GET /user_profile  (X)
GET /UserProfile   (X) 
```

> 카멜케이스는 가독성이 좋지만 URL은 대소문자를 구분하므로 하이픈이 웹 표준 및 일관성에 부합합니다.

<br/>

## RESTful 설계 안티패턴 예시
> RESTful하게 설계했다고 해도 실제로는 REST의 철학을 위반하는 경우가 많습니다.

| 안티패턴               | 예시                                           | 문제가 되는 이유                                                                    |
| ------------------ | -------------------------------------------- | ---------------------------------------------------------------------------- |
| 동사형 URI       | `/getUser`, `/deletePost`                    | REST는 동작이 아닌 **리소스(명사)** 중심으로 설계되어야 합니다. 동작은 HTTP 메서드로 표현되어야 합니다. |
| 무조건 POST 사용    | `/createUser`를 POST로 처리                      | 모든 요청을 POST로 처리하면 REST의 의도 명확성이 사라지고 캐싱 등의 HTTP 장점을 활용할 수 없습니다                |
| 상태를 URI로 표현    | `/orders/paid`                               | 리소스의 상태는 URI가 아닌 리소스의 **속성 값**으로 표현해야 합니다. URI는 리소스 식별에만 사용되어야 합니다.           |
| 과도하게 깊은 URI 구조 | `/users/123/orders/456/items/789/products/1` | 복잡한 경로는 클라이언트와-서버 간 의존성을 높이고 유지보수가 어려워집니다.       |



<br/>

## REST API 설계 시 고려사항

- URI는 리소스를 표현하고 동작은 HTTP 메소드로 표현합니다.
- 일관성 있는 네이밍과 구조는 사용성과 유지보수성을 높입니다.
- 요청은 리소스의 상태를 바꾸는 상태 전이(Transition)를 유발합니다. 클라이언트는 리소스 상태를 서버에 명확히 전달할 수 있습니다.


<br/>


## REST vs RESTful 비교

| 항목          | REST (개념) | RESTful (구현)        |
| ----------- | --------- | ------------------- |
| 정의          | 아키텍처 스타일  | REST 원칙을 따른 API 구현  |
| 필수 조건       | 명확히 정의 없음 | URI, 메소드, 무상태성 등 준수 |
| HTTP 사용 여부  | 꼭 필요하지 않음 | HTTP 기반 통신 필수       |
| URI 규칙 등 준수 | 권장사항      | 반드시 지켜야 함           |

> 모든 HTTP API가 RESTful한 것은 아닙니다. REST 원칙을 따르지 않으면 단순 HTTP API일 뿐입니다.

<br/>

## 웹 서비스 아키텍처 스타일 비교

| 스타일     | 특징                  | 장점                   | 단점                 |
| ------- | ------------------- | -------------------- | ------------------ |
| REST    | HTTP 기반, 리소스 중심 URI  | 간결함, 확장성, 독립성        | 상태 저장이나 실시간 처리에 약함 |
| SOAP    | XML 기반, 엄격한 스펙      | 보안/트랜잭션 지원, ACID 보장  | 구현 복잡, 데이터 과다      |
| GraphQL | 요청 데이터 구조 지정 가능     | 필요한 데이터만 요청 가능       | 쿼리 복잡성, 초기 설정 부담   |
| gRPC    | Protobuf, HTTP/2 기반 | 빠름, 양방향 스트리밍, 다언어 지원 | 학습 곡선 높음, 환경 제약    |


<br/>


## 추가 설명

### 웹 서비스 아키텍처 스타일 종류

#### REST (Representational State Transfer)

##### 특징
HTTP 프로토콜을 기반으로 리소스(데이터)을 URI로 식별하고 HTTP 메소드(GET, POST, PUT, DELETE 등)를 통해 리소스를 조작하는 아키텍처 스타일입니다.

##### 장점
설계가 간결하고 직관적이며 클라이언트와 서버의 독립성이 보장되고 확장성이 뛰어납니다.

##### 단점
복잡한 상태 저장 기능이나 실시간 처리에는 적합하지 않을 수 있습니다.

---

#### SOAP (Simple Object Access Protocol)

##### 특징
XML을 기반으로 한 메시지 전송 프로토콜이며 메시지 구조와 전송 방식에 대해 엄격한 규약을 따릅니다. 
HTTP 외에도 SMTP, FTP 등 다양한 전송 방식을 사용할 수 있습니다.

##### 장점
보안, 트랜잭션 관리, ACID(Atomicity, Consistency, Isolation, Durability)와 같은 고급 기능을 지원합니다.

##### 단점
구현이 복잡하고 XML을 사용하여 데이터 크기가 커질 수 있으며 성능에 부담이 될 수 있습니다.

---

#### GraphQL

##### 특징 
클라이언트가 요청하는 데이터의 구조를 명시적으로 지정할 수 있는 API 쿼리 언어입니다. 
하나의 엔드포인트를 통해 클라이언트가 원하는 데이터만 선택적으로 요청할 수 있습니다.

##### 장점
클라이언트가 필요한 데이터만 가져올 수 있어 효율적인 데이터 처리가 가능하며 복잡한 관계를 쉽게 다룰 수 있습니다.

##### 단점
서버에서 복잡한 쿼리를 처리하는 데 시간이 소요될 수 있으며 초기 설정이 복잡할 수 있습니다.



---

#### gRPC (Google Remote Procedure Call)

##### 특징
구글이 개발한 고성능 원격 프로시저 호출(RPC) 시스템으로, Protobuf(Protocol Buffers)를 사용하여 데이터를 직렬화하며 HTTP/2를 기반으로 높은 성능을 제공합니다.

##### 장점
데이터 직렬화가 빠르고 효율적이며 양방향 스트리밍을 지원하고 다양한 언어를 지원합니다.

##### 단점
REST에 비해 학습 곡선이 가파르며 HTTP/2를 지원하는 환경이 필요합니다.

<br/>

## Query Parameter vs Path Parameter 

| 구분              | 언제 사용              | 예시                                        |
| --------------- | ------------------- | ----------------------------------------- |
| Path Parameter  | 리소스를 **고유하게 식별**할 때 | `GET /users/{userId}` → 특정 사용자 조회             |
| Query Parameter | **검색, 필터링, 정렬**에 사용 | `GET /users?age=25&sort=desc` → 조건에 맞는 사용자 검색 |

> Path는 리소스를 식별하고 Query는 선택적 세부 조건을 전달할 때 사용해야 합니다.

<br/>


### 카멜케이스는 왜 지양 해야할까?

RESTful API에서는 모든 글자를 소문자로 작성하고 단어 구분은 하이픈(-)을 사용하는 것이 표준입니다.

| 스타일         | 예시           | 권장 여부 |
| ----------- | ------------ | ----- |
| CamelCase   | `/userList`  | X     |
| Underscore  | `/user_list` | X     |
| Hyphen-case | `/user-list` | O     |

#### 이유
- 가독성: 하이픈은 단어 구분이 명확하며 URI는 대소문자를 구분하기 때문에 CamelCase보다 읽기 어렵습니다.
- 일관성: 대부분의 RESTful 설계 가이드에서 하이픈 사용을 권장합니다.
- 웹 표준 준수: W3C 등에서도 하이픈을 표준 URL 구분자로 채택하고 있습니다.

> 단, 내부 팀 규칙에서 CamelCase를 사용하는 경우도 있으므로 가장 중요한 것은 일관성 유지입니다. 
{: .prompt-tip }

<br/>


## 결론
REST API는 웹 서비스의 리소스 중심 구조를 효율적으로 구현할 수 있는 가장 보편적인 아키텍처입니다.
명확한 URI 설계, 일관된 메소드 사용, 무상태성 유지가 RESTful API의 핵심 원칙입니다.



### RESTful 설계 요약

| 항목       | 설명                       |
| -------- | ------------------------ |
| URI      | 리소스 중심 명사형 URI, 계층 구조 유지  |
| HTTP 메소드 | CRUD 기능에 맞는 메소드 사용       |
| 무상태성     | 요청 간 상태 미보존, 인증 정보 포함 필요 |
| 표현       | JSON 중심의 리소스 표현           |
| 일관성      | 규칙 있는 URI/응답 형식 제공       |

> RESTful API는 규칙과 원칙을 지키는 것이 중요합니다. <br/>
> 좋은 API는 읽기 쉽고 사용하기 쉬우며 유지보수가 용이합니다.
{: .prompt-tip }


