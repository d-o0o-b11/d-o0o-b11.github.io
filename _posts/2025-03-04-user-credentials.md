---
title: 로그인이 필수는 아니다.  #JWT 토큰을 사용한 이유
description: 우리는 어떻게 인증해야 하는가?
categories: [Dev-Notes, Practice]
tags: [typography]
math: true
mermaid: true
---

## 개요
대부분 온라인 서비스에서 로그인은 당연한 기능처럼 여겨집니다.  
하지만 정말 반드시 필요한 걸까요?

- 로그인이 없다면 보안이 무너질까?
- 사용자 경험은 더 좋아질 수 있을까?

서비스를 설계할 때 **인증(Authentication)** 은 반드시 고려해야 할 요소입니다.  
사용자를 어떻게 식별할지, 어떻게 안전하게 보호할지 그리고 사용자 경험을 해치지 않으면서 인증할 수 있을지에 대한 고민이 필요합니다.



<br/>


## 로그인 없이도 사용자 구분이 가능하다
로그인의 본질은 **요청을 누가 보냈는지를 식별하는 것**입니다.  
간단한 이름이나 닉네임으로도 사용자를 구분할 수 있습니다.

하지만 여기서 몇 가지 문제가 발생합니다.
1. 오타로 인해 다른 사용자로 인식될 수 있습니다.
2. 누군가 다른 사람인 척할 수 있습니다.

이 문제를 해결하려면 사용자가 본인임을 증명할 방법이 필요합니다. 
일반적으로는 ID/PW 조합을 사용한 인증 방식을 사용합니다.

<br/>

## User Credentials란?
사용자가 누구인지를 증명하는 정보입니다.

ex.
- 사용자 이름  
- ID/PW  
- 세션 ID  
- 토큰

단순한 문자열은 쉽게 노출되거나 조작될 수 있으므로 다음과 같은 방식으로 보완합니다.
1. **전송 과정 보안**
    - `HTTPS`로 네트워크 상에서 데이터가 암호화되도록 합니다.
2. **조작 방지**
    - `Session` 또는 `Token`을 사용하여 검증된 사용자만 접근할 수 있도록 합니다.



<br/>

## 로그인은 어떻게 동작할까?
매 요청마다 ID/PW를 보내는 방식은 불편합니다.  
→ 그래서 "로그인"이라는 개념이 생겼습니다.

### 로그인 흐름
1. ID/PW로 최초 인증  
2. **Token 발급** (또는 세션 생성)  
3. 이후 요청에서는 Token을 통해 사용자 식별


<br/>

## Token과 Session은 User Credentials의 또 다른 형태일 뿐
```text
로그인의 본질 = User Credentials를 안전하게 전달하는 과정
```

가장 단순한 형태는 사용자의 이름이 될 수도 있지만 보안적으로 취약하기 때문에 더 안전한 User Credentials 방식인 Session과 Token을 활용합니다.

>Token과 Session은 결국 더 안전한 User Credentials의 포장 방식입니다.
{: .prompt-info }



<br/>

## 로그인 적용하며 고민했던 점들

### 1. JWT의 AT/RT 구조 문제
#### 문제
JWT는 서버 상태를 저장하지 않기 때문에 만료된 Access Token을 서버에서 차단하기 어렵다.

→ 로그아웃했는데도 기존 AT로 API 요청이 가능하다.

#### 해결
- Refresh Token은 DB에서 관리해 로그아웃 시 삭제하도록 했습니다.
- AT는 블랙리스트를 도입해 강제 만료 처리를 했습니다.


>더 이상 만료된 AT가 API 요청에 사용될 수 없도록 개선했습니다! 😀
{: .prompt-tip }

<br/>

### 2. RT 저장 위치
#### 문제
- 로컬스토리지로 저장 시, XSS 위험
- DB 저장 시, I/O 비용

#### 해결
RT를 DB에 저장하고 클라이언트에는 HttpOnly Cookie로 전달해 접근 제한했습니다.

<!-- ### 2. RT를 어떻게 관리할까?
JWT를 사용할 때 RT를 어디에 저장할 것인지도 중요한 고민이었습니다.

#### 문제점
- RT를 브라우저 스토리지에 저장하면 보안 이슈 발생 가능
- RT를 DB에 저장하면 추가적인 I/O 비용 발생

#### 해결 방법
- RT를 DB에 저장 (보안 강화를 위해)
- HttpOnly 쿠키에 저장하여 클라이언트에서 접근 불가능하도록 처리 -->

>보안성과 편의성을 모두 잡을 수 있었습니다! 🤩
{: .prompt-tip }

<br/>

### 3. 해커톤에서 로그인 기능이 필요한가?
#### 문제
- 해커톤에서는 보안, 확장성, 사용자 경험보단 빠르게 MVP를 개발하는 것이 중요합니다.
- 복잡한 로그인 구현은 시간 소모가 큽니다.

#### 해결
사용자의 PK를 Token으로 발급하여 인증보다는 "식별"에 초점을 두었습니다.


>MVP를 더 빠르게 개발할 수 있었습니다! 😊
{: .prompt-tip }

<br/>


### 4. 쿠키 활용
JWT를 저장할 때 쿠키를 사용하면 클라이언트에서 로컬스토리지 같은 별도의 저장 공간을 사용하지 않아도 되며 보안성이 더 강화될 수 있습니다.

#### 장점
- `HttpOnly` 옵션을 사용하면 클라이언트에서 접근할 수 없기 때문에 XSS 공격을 방어할 수 있습니다.
- 서버에서 `cookie.get`(쿠키 자동 파싱 기능)을 통해 쉽게 접근 가능하여 프론트엔드에서 토큰을 관리할 필요가 없습니다.
- 같은 도메인 내에서는 쿠키가 자동 전송되므로 API 요청 시 인증 과정을 간편하게 처리할 수 있습니다.

>**주의할 점** <br/>
>도메인이 다르면 쿠키가 공유되지 않습니다!
{: .prompt-info }

<br/>


## 결론
로그인이란 결국 **"내가 누구인지 증명하는 과정"**입니다.
이 과정을 어떻게 구현할지는 서비스의 성격에 따라 달라져야 합니다.

### 고려할 요소
- 보안이 중요한가?
- 확장성이 중요한가?
- UX를 해치지 않는가?

#### 최적의 선택 예시
- JWT + HttpOnly 쿠키 + 짧은 AT 만료시간 + RT 관리
- Session을 쓸 경우 Redis 등 세션 스토리지와 함께 사용

> 인증은 기술 선택이 아니라 설계의 결과물입니다.
{: .prompt-tip }


<br/>

## 회고
인증은 단순히 로그인 기능을 구현하는 것이 아니라 서비스의 철학과 보안 수준, 사용자 경험을 어떻게 정의하느냐의 문제라는 것을 깨달았습니다.

특히 JWT 구조를 적용하면서 stateless한 시스템의 한계와 그 안에서 유연하게 보안을 강화하는 방법에 대해 많이 고민할 수 있었습니다.

기능을 만드는 속도보다 기능을 얼마나 안전하게 만들 것인지, 어떤 유저 경험을 설계할 것인지에 대한 고민이 훨씬 중요하다는 것을 느꼈습니다.


<br/>
<br/>

## 추가 설명
Session 기반 인증과 JWT 기반 인증의 개념, 장단점 비교 등  
인증 방식 전반에 대한 내용은 아래 글에서 먼저 자세히 정리해두었습니다.

👉 [JWT vs 세션 인증 방식 개요 정리](https://d-o0o-b11.github.io/posts/1-session-vs-jwt/)

이 글에서는 인증 방식 선택 시 고려해야 할 요소들과 각 방식이 어떤 상황에서 적절한지를 다루고 있습니다.

> 인증 방식의 기본 개념이 궁금하다면 위 링크를 먼저 확인해보시는 걸 추천드립니다!
{: .prompt-info }

<!-- ## 추가 설명

### Session 기반 인증
>서버가 상태를 저장하며 인증 관리

#### 장점
- 서버에서 세션을 관리하기 때문에 보안성이 상대적으로 높습니다.
- 세션 정보를 변경하면 즉시 반영할 수 있어 유효성을 조정하기 쉽습니다.

#### 단점
- 서버에서 세션을 저장해야 하므로 확장성이 낮습니다.
- 여러 서버에서 세션을 공유하려면 별도의 세션 스토리지(Redis 등)가 필요합니다.

<br/>

### JWT 기반 인증
>클라이언트가 토큰을 보관하며 인증 관리

#### 장점
- 서버에 상태 정보를 저장할 필요 없이 stateless하게 인증 가능하여 확장성이 좋습니다.
- JWT 안에 필요한 정보(사용자 ID, 권한 등)를 담아 한 번 발급하면 별도의 서버 조회 없이 검증할 수 있습니다.

#### 단점
- 토큰이 한 번 발급되면 변조가 어렵기 때문에 강제 만료하려면 추가적인 블랙리스트 관리가 필요합니다.
- 토큰 크기가 커질수록 네트워크 부담이 증가할 수 있습니다.

<br/> -->